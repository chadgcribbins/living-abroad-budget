# MASTER TASK LIST


## TASK 001

# Task ID: 1
# Title: Setup Project Repository
# Status: done
# Dependencies: None
# Priority: high
# Description: Initialize the project repository with Next.js, React, and TailwindCSS + DaisyUI as specified in the PRD.
# Details:
Create a new Next.js project with TypeScript support. Install and configure TailwindCSS with DaisyUI for UI components. Set up the basic folder structure following Next.js conventions. Initialize Git repository and create an initial commit.

# Test Strategy:
Verify that the development server runs without errors and the basic Next.js page loads correctly with TailwindCSS styles applied.


## TASK 002

# Task ID: 2
# Title: Create Basic Project Structure
# Status: done
# Dependencies: 1
# Priority: high
# Description: Set up the foundational project structure including pages, components, and utility folders.
# Details:
Create folders for components, hooks, utils, types, and pages. Set up a basic layout component with header and footer. Create placeholder files for main pages based on the user flow. Configure global styles and theme variables in Tailwind config.

# Test Strategy:
Review the project structure to ensure it follows best practices and meets the requirements. Test that the layout component renders correctly.


## TASK 003

# Task ID: 3
# Title: Implement Currency API Integration
# Status: done
# Dependencies: 1
# Priority: high
# Description: Set up the integration with CurrencyAPI for exchange rate data as specified in the PRD.
# Details:
Create a utility function to fetch exchange rates from CurrencyAPI. Implement caching to minimize API calls. Create a context provider to make exchange rates available throughout the application. Include error handling and fallback values.

# Test Strategy:
Test API integration by making test calls and verifying response format. Ensure caching works correctly and that the context provider properly distributes currency data.


## TASK 004

# Task ID: 4
# Title: Design Data Models
# Status: done
# Dependencies: 1
# Priority: high
# Description: Create TypeScript interfaces for all data models mentioned in the conceptual data model section.
# Details:
Define TypeScript interfaces for Household, Income, Housing, Transport, Lifestyle, Education, Healthcare, EmergencyBuffer, FX, and Summary. Include all fields mentioned in the PRD with appropriate types. Create utility functions for calculations and data transformations.

# Test Strategy:
Review interfaces for completeness against the PRD requirements. Write unit tests for utility functions to ensure correct calculations.

# Subtasks:
## 1. Define Core Financial Entity Interfaces [done]
### Dependencies: None
### Description: Create TypeScript interfaces for the fundamental financial entities: Household and Income models with all required properties and types.
### Details:
Implementation steps:
1. Create a new file `models/core.ts`
2. Define the Household interface with properties for household members, dependents, location data, etc.
3. Define the Income interface with properties for income sources, salary details, investment income, etc.
4. Add JSDoc comments to document each property's purpose and constraints
5. Include appropriate TypeScript types (string, number, boolean, Date, etc.)
6. Define any necessary enum types for categorical fields

Testing approach:
- Create sample objects that implement these interfaces
- Verify type checking works correctly with TypeScript compiler
- Ensure all fields from the PRD are represented

## 2. Define Expense Category Interfaces [done]
### Dependencies: 4.1
### Description: Create TypeScript interfaces for expense-related models: Housing, Transport, Lifestyle, Education, and Healthcare.
### Details:
Implementation steps:
1. Create a new file `models/expenses.ts`
2. Define the Housing interface with properties for mortgage/rent, utilities, maintenance, etc.
3. Define the Transport interface with properties for vehicles, public transport, fuel costs, etc.
4. Define the Lifestyle interface with properties for entertainment, dining, subscriptions, etc.
5. Define the Education interface with properties for tuition, books, courses, etc.
6. Define the Healthcare interface with properties for insurance, medications, procedures, etc.
7. Add JSDoc comments for all properties
8. Ensure consistent typing conventions with core models

Testing approach:
- Create sample objects for each expense category
- Verify type compatibility with the Household model
- Test with both minimal and comprehensive data examples

## 3. Define Financial Planning Interfaces [done]
### Dependencies: 4.1, 4.2
### Description: Create TypeScript interfaces for financial planning models: EmergencyBuffer, FX (Foreign Exchange), and Summary.
### Details:
Implementation steps:
1. Create a new file `models/planning.ts`
2. Define the EmergencyBuffer interface with properties for savings targets, current amounts, etc.
3. Define the FX interface with properties for currency exchange rates, foreign holdings, etc.
4. Define the Summary interface that aggregates financial data from other models
5. Ensure Summary interface can reference other model types appropriately
6. Add calculated fields that will be derived from other models
7. Document relationships between these models and previously defined ones

Testing approach:
- Create sample objects implementing these interfaces
- Verify they can correctly reference other model types
- Test with realistic financial planning scenarios

## 4. Implement Model Relationship Types [done]
### Dependencies: 4.1, 4.2, 4.3
### Description: Define TypeScript types that express relationships between different financial models and create a unified financial profile type.
### Details:
Implementation steps:
1. Create a new file `models/relationships.ts`
2. Define a FinancialProfile interface that combines all previously defined models
3. Create appropriate nested type structures to represent hierarchical relationships
4. Define union types for fields that can accept multiple types of values
5. Create index types for lookups between related models
6. Define mapping types between related entities (e.g., household member to income sources)
7. Ensure type safety across model relationships

Testing approach:
- Create a complete financial profile object
- Test traversing relationships between models
- Verify TypeScript compiler catches inconsistent relationships

## 5. Create Calculation Utility Functions [done]
### Dependencies: 4.1, 4.2, 4.3, 4.4
### Description: Implement utility functions for financial calculations across models, such as total income, expense ratios, and savings projections.
### Details:
Implementation steps:
1. Create a new file `utils/calculations.ts`
2. Implement functions for calculating total household income
3. Implement functions for calculating expense totals by category
4. Create functions for determining expense-to-income ratios
5. Implement savings rate and projection calculations
6. Add emergency fund adequacy calculations
7. Create utility functions for currency conversion using FX rates
8. Ensure all functions are properly typed with the model interfaces

Testing approach:
- Write unit tests with sample financial data
- Verify calculations match expected results
- Test edge cases (zero income, negative values, etc.)
- Ensure type safety for all function parameters and return values

## 6. Implement Data Transformation Utilities [done]
### Dependencies: 4.1, 4.2, 4.3, 4.4, 4.5
### Description: Create utility functions for transforming, validating, and normalizing financial data across all models.
### Details:
Implementation steps:
1. Create a new file `utils/transformations.ts`
2. Implement functions to convert raw data inputs to model-compliant objects
3. Create validation functions to check data integrity and constraints
4. Implement normalization functions for standardizing data formats
5. Add utility functions for data aggregation across models
6. Create serialization/deserialization functions for storage and retrieval
7. Implement data migration utilities for handling model changes
8. Add helper functions for generating default/empty model instances

Testing approach:
- Test with various input data formats
- Verify validation correctly identifies invalid data
- Test transformation of incomplete data
- Ensure round-trip transformations preserve data integrity
- Verify compatibility with calculation utilities



## TASK 005

# Task ID: 5
# Title: Create Country Selection Component
# Status: done
# Dependencies: 2, 4
# Priority: high
# Description: Implement the origin and destination country selector as the first step in the user flow.
# Details:
Create a dropdown component for selecting origin and destination countries. For MVP, focus on UK to Portugal path but design for extensibility. Include country flags and names. Store selection in application state.

# Test Strategy:
Test the component renders correctly with all required countries. Verify that selection updates the application state correctly.


## TASK 006

# Task ID: 6
# Title: Implement Household Setup Component
# Status: done
# Dependencies: 2, 4
# Priority: high
# Description: Create the component for users to define their household composition.
# Details:
Build a form component allowing users to specify number of people and their age groups (Baby, Primary, Secondary, College, Adult, Parent, Grandparent). Include input for duration of stay in years. Store this information in application state.

# Test Strategy:
Test form validation for all inputs. Verify that household data is correctly stored and accessible to other components.


## TASK 007

# Task ID: 7
# Title: Develop Residency Regime Selector
# Status: done
# Dependencies: 5
# Priority: high
# Description: Create a component to select the tax/residency regime (e.g., NHR toggle for Portugal).
# Details:
Implement a toggle or dropdown for selecting residency regime. For MVP, focus on Portugal's NHR option. Include brief explanatory text about the selected regime. Connect selection to tax calculation logic.

# Test Strategy:
Verify that toggling between regimes updates the state correctly. Test that explanatory text changes appropriately based on selection.


## TASK 008

# Task ID: 8
# Title: Build Income Input Module
# Status: done
# Dependencies: 3, 4, 5
# Priority: high
# Description: Create the comprehensive income input section for salaries, passive income, and one-off inflows.
# Details:
Implement form components for Partner 1 & 2 salaries with currency selection. Create add/remove functionality for multiple passive income sources with type, amount, and frequency inputs. Add one-off inflows section with date inputs. Show all values in both origin and destination currencies.

# Test Strategy:
Test adding and removing income sources. Verify currency conversions are correct. Ensure all income types are correctly summed in calculations.

# Subtasks:
## 1. Create Base Income State Management [done]
### Dependencies: None
### Description: Set up the core state management structure for all income types with appropriate interfaces and initial state values
### Details:
Implementation steps:
1. Define TypeScript interfaces for all income types (salary, passive, one-off)
2. Create a central income state object with appropriate nested structure
3. Implement reducer functions for adding, updating, and removing income entries
4. Set up context provider to make income state available throughout the application
5. Add utility functions for currency-related calculations
6. Test the state management by manually triggering state changes and verifying the state updates correctly

<info added on 2025-04-16T18:02:46.850Z>
# Implementation Plan for Subtask 8.1 (Income State Management):

1. **Approach:** Use React Context API (`createContext`, `useReducer`) and a custom hook (`useIncome`). This aligns with the existing `CurrencyContext.tsx` pattern. Avoid introducing Zustand/Redux at this stage.
2. **Interfaces:** Define detailed TypeScript interfaces in `src/types/income.types.ts` for `SalaryDetails`, `PassiveIncome`, `OneOffInflow`, and the main `IncomeState`. Ensure types accommodate currency selection and frequency where needed.
3. **Reducer:** Create `incomeReducer` in a new file `src/context/IncomeContext.tsx`. Implement actions:
   * `UPDATE_PARTNER1_SALARY`
   * `UPDATE_PARTNER2_SALARY`
   * `ADD_PASSIVE_INCOME`
   * `UPDATE_PASSIVE_INCOME` (by ID)
   * `REMOVE_PASSIVE_INCOME` (by ID)
   * `ADD_ONE_OFF_INFLOW`
   * `UPDATE_ONE_OFF_INFLOW` (by ID)
   * `REMOVE_ONE_OFF_INFLOW` (by ID)
   * `SET_INCOME_STATE` (for loading initial/saved state)
   * `UPDATE_BASE_CURRENCY` (or handle via separate context)
   * `UPDATE_EXCHANGE_RATES` (or handle via separate context)
4. **Context & Provider:** Define `IncomeContext` and `IncomeProvider` component in `src/context/IncomeContext.tsx`. The provider will use `useReducer` with the `incomeReducer` and provide `state` and `dispatch`.
5. **Hook:** Create `useIncome` hook in `src/context/IncomeContext.tsx` for easy consumption.
6. **Integration:** Wrap the application layout (likely in `src/app/layout.tsx` below `CurrencyProvider` or within `src/app/page.tsx`) with `<IncomeProvider>`.
7. **Initial State:** Define the `initialIncomeState` according to the `IncomeState` interface, using defaults like empty arrays for lists and potentially null/undefined for salaries until set.
</info added on 2025-04-16T18:02:46.850Z>

## 2. Implement Salary Input Components [done]
### Dependencies: 8.1
### Description: Build form components for Partner 1 & Partner 2 salary inputs with currency selection
### Details:
Implementation steps:
1. Create a reusable salary input component with fields for amount and currency
2. Implement separate instances for Partner 1 and Partner 2
3. Add validation for numeric inputs and required fields
4. Connect components to the income state management from subtask 1
5. Style the components according to the application design system
6. Test the components by entering various salary values and verifying the state updates correctly
7. Ensure proper handling of currency selection changes

<info added on 2025-04-16T18:21:48.773Z>
# Implementation Plan (Subtask 8.2):

1. **File Structure:** Create `src/components/Income/SalaryInput.tsx` for the reusable component and `src/components/Income/IncomeModule.tsx` as a container.
2. **Reusable Component (`SalaryInput.tsx`):**
   * Define `SalaryInputProps`: `partnerLabel: string`, `value: SalaryDetails | undefined`, `onUpdate: (payload: SalaryDetails | undefined) => void`.
   * Component receives these props.
   * Use internal state (`useState`) for input values (amount, frequency, currency) derived initially from the `value` prop.
   * Render labeled inputs:
       * Amount (`<input type="number">`)
       * Frequency (`<select>` with 'Annual', 'Monthly')
       * Currency (`<select>`). Use `useCurrency` hook to get available `rates` and populate options (displaying currency codes).
   * On input changes (`onChange` or `onBlur`), update internal state.
   * Use `useEffect` hook to call the `onUpdate` prop whenever the internal state representing a complete `SalaryDetails` object changes. Handle the case where inputs are incomplete (e.g., amount is empty) by potentially calling `onUpdate(undefined)`.
   * Apply Tailwind/DaisyUI classes (`input`, `select`, `label`, `form-control`).
3. **Container Component (`IncomeModule.tsx`):**
   * Import `SalaryInput` and `useIncome`.
   * Call `useIncome` to get `state` and `dispatch`.
   * Define handler functions:
       * `handleUpdatePartner1(payload: SalaryDetails | undefined)`: Calls `dispatch({ type: 'UPDATE_PARTNER1_SALARY', payload })`.
       * `handleUpdatePartner2(payload: SalaryDetails | undefined)`: Calls `dispatch({ type: 'UPDATE_PARTNER2_SALARY', payload })`.
   * Render a container `div` (e.g., with heading 'Income').
   * Render `<SalaryInput partnerLabel="Partner 1" value={state.partner1Salary} onUpdate={handleUpdatePartner1} />`.
   * Render `<SalaryInput partnerLabel="Partner 2" value={state.partner2Salary} onUpdate={handleUpdatePartner2} />`.
4. **Integration (`page.tsx`):**
   * Import `IncomeModule`.
   * Add `<IncomeModule />` to the main page component's render structure.
</info added on 2025-04-16T18:21:48.773Z>

## 3. Build Passive Income Management Section [done]
### Dependencies: 8.1
### Description: Create the passive income section with add/remove functionality and inputs for type, amount, and frequency
### Details:
Implementation steps:
1. Develop a passive income entry component with fields for income type (dropdown), amount, frequency, and currency
2. Implement an 'Add Income Source' button that creates a new entry in the state
3. Add a remove button for each passive income entry
4. Connect the components to the income state management
5. Implement validation for all input fields
6. Test adding multiple passive income sources and removing them
7. Verify that all input changes correctly update the state

<info added on 2025-04-16T18:24:24.122Z>
# Implementation Plan (Subtask 8.3):

1. **File Structure:** Create `src/components/Income/PassiveIncomeItem.tsx` for the individual item rows.
2. **Item Component (`PassiveIncomeItem.tsx`):**
   * Define `PassiveIncomeItemProps`: `item: PassiveIncome`, `onUpdate: (updatedItem: PassiveIncome) => void`, `onRemove: (id: string) => void`.
   * Component receives these props.
   * Use internal state (`useState`) for input values (type, amount, frequency, currency) derived from the `item` prop.
   * Render labeled inputs:
       * Type (`<input type="text">` or `<select>` if predefined types exist)
       * Amount (`<input type="number">`)
       * Frequency (`<select>` with options from `IncomeFrequency` type)
       * Currency (`<select>` using `useCurrency` hook).
   * Render a "Remove" button (e.g., using an icon) that calls `onRemove(item.id)`.
   * On input changes, update internal state.
   * Use `useEffect` to call `onUpdate` prop whenever the internal state forms a complete, valid, and *changed* `PassiveIncome` object (compared to the original `item` prop).
   * Apply Tailwind/DaisyUI styling for inputs, button, and row layout.
3. **Container Component (`IncomeModule.tsx` - Modify):
   * Add a new `div` section below salaries with a heading like "Passive Income".
   * Import `PassiveIncomeItem`.
   * Define handler functions:
       * `handleUpdatePassiveIncome(updatedItem: PassiveIncome)`: Dispatches `{ type: 'UPDATE_PASSIVE_INCOME', payload: updatedItem }`.
       * `handleRemovePassiveIncome(id: string)`: Dispatches `{ type: 'REMOVE_PASSIVE_INCOME', payload: { id } }`.
       * `handleAddPassiveIncome()`: Dispatches `{ type: 'ADD_PASSIVE_INCOME', payload: { type: '', amount: 0, frequency: 'Monthly', currency: '' /* Default Currency? */ } }`.
   * Map over `state.passiveIncomes`:
       * For each `income` item, render `<PassiveIncomeItem key={income.id} item={income} onUpdate={handleUpdatePassiveIncome} onRemove={handleRemovePassiveIncome} />`.
   * Add an "Add Passive Income" button (`<button>`) at the end of the section, calling `handleAddPassiveIncome` onClick.
</info added on 2025-04-16T18:24:24.122Z>

## 4. Create One-Off Inflows Section [done]
### Dependencies: 8.1
### Description: Implement the one-off inflows section with date, amount, and description inputs
### Details:
Implementation steps:
1. Build a one-off inflow entry component with date picker, amount input, description field, and currency selection
2. Add functionality to create and remove one-off inflow entries
3. Connect the components to the income state management
4. Implement validation for required fields and proper date formats
5. Ensure the date picker has appropriate date range restrictions if needed
6. Test adding and removing one-off inflows and verify state updates
7. Check that date inputs are properly formatted and stored

<info added on 2025-04-16T18:33:52.812Z>
# Implementation Plan (Subtask 8.4):

## Component Implementation Details

### OneOffInflowItem.tsx
```tsx
import React, { useState, useEffect } from 'react';
import { useCurrencies } from '../../hooks/useCurrencies';
import { OneOffInflow } from '../../types/income';

interface OneOffInflowItemProps {
  item: OneOffInflow;
  onUpdate: (updatedItem: OneOffInflow) => void;
  onRemove: (id: string) => void;
}

export const OneOffInflowItem: React.FC<OneOffInflowItemProps> = ({ item, onUpdate, onRemove }) => {
  const { currencies, defaultCurrency } = useCurrencies();
  const [description, setDescription] = useState(item.description || '');
  const [amount, setAmount] = useState(item.amount || 0);
  const [currency, setCurrency] = useState(item.currency || defaultCurrency);
  const [date, setDate] = useState(item.date || new Date().toISOString().split('T')[0]);
  
  useEffect(() => {
    // Only update if values have changed and are valid
    if (description && amount > 0 && currency && date &&
        (description !== item.description || 
         amount !== item.amount ||
         currency !== item.currency ||
         date !== item.date)) {
      onUpdate({
        ...item,
        description,
        amount,
        currency,
        date
      });
    }
  }, [description, amount, currency, date]);

  return (
    <div className="card bg-base-200 shadow-sm p-4 mb-2">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
        <div className="form-control">
          <label className="label">
            <span className="label-text">Date</span>
          </label>
          <input
            type="date"
            className="input input-bordered w-full"
            value={date}
            onChange={(e) => setDate(e.target.value)}
          />
        </div>
        
        <div className="form-control">
          <label className="label">
            <span className="label-text">Amount</span>
          </label>
          <input
            type="number"
            className="input input-bordered w-full"
            value={amount}
            min="0"
            step="0.01"
            onChange={(e) => setAmount(parseFloat(e.target.value) || 0)}
          />
        </div>
        
        <div className="form-control">
          <label className="label">
            <span className="label-text">Currency</span>
          </label>
          <select 
            className="select select-bordered w-full"
            value={currency}
            onChange={(e) => setCurrency(e.target.value)}
          >
            {currencies.map(curr => (
              <option key={curr} value={curr}>{curr}</option>
            ))}
          </select>
        </div>
        
        <div className="form-control">
          <label className="label">
            <span className="label-text">Description</span>
          </label>
          <div className="flex">
            <input
              type="text"
              className="input input-bordered w-full"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
            />
            <button 
              className="btn btn-error ml-2" 
              onClick={() => onRemove(item.id)}
            >
              <i className="fas fa-trash"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

### State Management Updates
Add these reducer cases to handle one-off inflows:

```typescript
// In incomeReducer.ts
case 'ADD_ONE_OFF_INFLOW':
  return {
    ...state,
    oneOffInflows: [
      ...state.oneOffInflows,
      {
        id: generateId(), // Implement or import this utility function
        description: '',
        amount: 0,
        currency: state.defaultCurrency || 'USD',
        date: new Date().toISOString().split('T')[0]
      }
    ]
  };

case 'UPDATE_ONE_OFF_INFLOW':
  return {
    ...state,
    oneOffInflows: state.oneOffInflows.map(item => 
      item.id === action.payload.id ? action.payload : item
    )
  };

case 'REMOVE_ONE_OFF_INFLOW':
  return {
    ...state,
    oneOffInflows: state.oneOffInflows.filter(item => item.id !== action.payload.id)
  };
```

### Types Definition
```typescript
// In types/income.ts
export interface OneOffInflow {
  id: string;
  description: string;
  amount: number;
  currency: string;
  date: string; // ISO format date string
}
```

### Validation Functions
```typescript
// Utility function for validation
export const validateOneOffInflow = (inflow: OneOffInflow): string[] => {
  const errors: string[] = [];
  
  if (!inflow.description.trim()) {
    errors.push('Description is required');
  }
  
  if (!inflow.amount || inflow.amount <= 0) {
    errors.push('Amount must be greater than zero');
  }
  
  if (!inflow.currency) {
    errors.push('Currency is required');
  }
  
  if (!inflow.date || !/^\d{4}-\d{2}-\d{2}$/.test(inflow.date)) {
    errors.push('Valid date is required (YYYY-MM-DD)');
  }
  
  return errors;
}
```

### Testing Considerations
1. Test adding one-off inflows with various date formats
2. Verify currency conversion works correctly when calculating totals
3. Test edge cases like extremely large amounts
4. Ensure date validation works properly
5. Test sorting of one-off inflows by date
</info added on 2025-04-16T18:33:52.812Z>

## 5. Implement Currency Conversion Display [done]
### Dependencies: 8.1, 8.2, 8.3, 8.4
### Description: Add functionality to display all income values in both origin and destination currencies
### Details:
Implementation steps:
1. Create a currency conversion service that can convert between different currencies
2. Modify the income display components to show values in both original and destination currencies
3. Implement a currency selection component for setting the destination currency
4. Add visual indicators to distinguish between original and converted values
5. Ensure currency symbols are displayed correctly
6. Test the conversion by changing currencies and verifying the displayed values update correctly
7. Add loading states for when conversion rates are being fetched

## 6. Integrate and Finalize Income Module [done]
### Dependencies: 8.2, 8.3, 8.4, 8.5
### Description: Combine all income components into a cohesive module with consistent styling and validation
### Details:
Implementation steps:
1. Create a parent Income Module component that incorporates all income sections
2. Implement consistent styling across all income components
3. Add section headers and descriptive text for each income type
4. Create a summary section that displays total income from all sources
5. Implement form-level validation that checks for required fields across all sections
6. Add appropriate error messages and validation feedback
7. Test the complete module by entering various income scenarios and verifying all functionality works together
8. Ensure responsive design works on different screen sizes



## TASK 009

# Task ID: 9
# Title: Implement Housing Module
# Status: done
# Dependencies: 3, 4
# Priority: high
# Description: Create the housing section with rent/buy toggle and relevant inputs for each option.
# Details:
Build a toggle between rent and buy options. For buying, include inputs for property price, down payment (fixed or %), mortgage term, and interest rate with calculated monthly payment. For renting, include monthly rent input. Add fields for annual maintenance, insurance, and property tax. Include option to model future housing upgrade.

# Test Strategy:
Test mortgage calculation accuracy. Verify that toggling between rent/buy shows/hides appropriate fields. Test that housing costs are correctly reflected in summary calculations.

# Subtasks:
## 1. Create Housing Module Base Structure with Rent/Buy Toggle [done]
### Dependencies: None
### Description: Implement the basic structure of the housing module with a toggle switch between rent and buy options
### Details:
Implementation details:
1. Create a new Housing component with a container layout
2. Implement a toggle switch component that allows users to select between 'Rent' and 'Buy' options
3. Set up state management to track the selected option (rent/buy)
4. Create conditional rendering logic based on the toggle state
5. Add appropriate styling for the module container and toggle
6. Implement event handlers for the toggle to update the state

Testing approach:
- Verify the toggle switches correctly between rent and buy
- Confirm the UI updates appropriately when toggle changes
- Test responsive layout on different screen sizes

## 2. Implement Buy Option Input Fields and Validation [done]
### Dependencies: 9.1
### Description: Create all input fields required for the buy option, including property price, down payment options, mortgage term, and interest rate
### Details:
Implementation details:
1. Create input fields for property price with currency formatting
2. Implement down payment section with radio buttons to choose between fixed amount or percentage
3. Add conditional input field based on down payment selection ($ amount or % value)
4. Create dropdown or slider for mortgage term selection (years)
5. Add interest rate input with percentage formatting
6. Implement validation for all fields (non-negative values, reasonable ranges)
7. Store all input values in state

Testing approach:
- Test input validation for each field
- Verify conditional rendering of down payment options
- Test edge cases (very large numbers, zero values)
- Confirm all inputs are correctly stored in state

## 3. Implement Rent Option Input Fields [done]
### Dependencies: 9.1
### Description: Create the input field for monthly rent amount with appropriate validation
### Details:
Implementation details:
1. Create input field for monthly rent with currency formatting
2. Implement validation for the rent input (non-negative values)
3. Store rent value in state
4. Ensure proper display when rent option is selected
5. Add any additional rent-specific fields if needed

Testing approach:
- Test input validation for rent field
- Verify the field is only displayed when rent option is selected
- Test edge cases (very large numbers, zero values)
- Confirm rent value is correctly stored in state

## 4. Implement Common Housing Expense Fields [done]
### Dependencies: 9.1, 9.2, 9.3
### Description: Add input fields for expenses common to both rent and buy options: annual maintenance, insurance, and property tax
### Details:
Implementation details:
1. Create input fields for annual maintenance costs with currency formatting
2. Add insurance cost input with currency formatting
3. Implement property tax input with option for percentage of property value or fixed amount
4. Add appropriate labels and help text explaining each field
5. Implement validation for all fields
6. Store all values in state
7. Ensure these fields appear regardless of rent/buy selection

Testing approach:
- Verify fields appear for both rent and buy options
- Test input validation for each field
- Confirm conditional property tax input works correctly
- Test that values are correctly stored in state

## 5. Implement Mortgage Payment Calculator [done]
### Dependencies: 9.2
### Description: Create the logic to calculate monthly mortgage payments based on user inputs and display the result
### Details:
Implementation details:
1. Implement mortgage calculation formula: M = P[r(1+r)^n]/[(1+r)^n-1] where:
   - M = monthly payment
   - P = principal (loan amount)
   - r = monthly interest rate (annual rate / 12 / 100)
   - n = number of payments (term in years * 12)
2. Calculate loan amount based on property price minus down payment
3. Create a display component to show the calculated monthly payment
4. Update calculation whenever relevant inputs change
5. Add formatting for currency display
6. Include breakdown of payment (principal vs. interest) if desired

Testing approach:
- Test calculation with various input combinations
- Verify calculation updates when inputs change
- Compare results with known mortgage calculators
- Test edge cases (very short/long terms, high/low interest rates)

## 6. Implement Future Housing Upgrade Modeling [done]
### Dependencies: 9.1, 9.2, 9.3, 9.4, 9.5
### Description: Add functionality to model a future housing upgrade with timing and cost projections
### Details:
Implementation details:
1. Create a collapsible section for future housing upgrade
2. Add toggle to enable/disable future upgrade modeling
3. Implement input for projected year of upgrade
4. Add fields for estimated future property value/rent
5. Create inputs for new mortgage terms if applicable
6. Implement logic to calculate financial impact of the upgrade
7. Display projected changes in monthly payments and overall financial impact
8. Ensure all inputs have appropriate validation

Testing approach:
- Test enabling/disabling the future upgrade section
- Verify all inputs work correctly and store values in state
- Test calculations for financial impact
- Confirm integration with the rest of the housing module
- Test that future projections update when current housing inputs change



## TASK 010

# Task ID: 10
# Title: Develop Transportation Module
# Status: done
# Dependencies: 4
# Priority: medium
# Description: Build the transportation section with car ownership options and public transport inputs.
# Details:
Create car ownership toggle (Yes/No). If Yes, add type selection (Electric/Gas) and purchase/lease toggle. Include inputs for car cost, monthly fuel/charging, insurance, and maintenance. Add fields for public transport and ride-share monthly averages. Include travel card costs input.

# Test Strategy:
Test that appropriate fields show/hide based on selections. Verify calculations for total transportation costs are accurate.

# Subtasks:
## 1. Define Transport Data Types [done]
### Dependencies: None
### Description: Create/update TypeScript interfaces in src/types/transport.types.ts to represent the state for this module (car ownership toggle, type, purchase/lease, costs, public transport fields).
### Details:


## 2. Create Transport Context/State Management [done]
### Dependencies: None
### Description: Set up state management (likely using React Context + Reducer, similar to Income) to hold and update the transport data.
### Details:


## 3. Implement Transport UI Component Structure [done]
### Dependencies: None
### Description: Create the main TransportModule.tsx component and basic layout, including the Car Ownership (Yes/No) toggle.
### Details:


## 4. Implement Car Ownership Input Fields [done]
### Dependencies: None
### Description: Add the conditional input fields for when Car Ownership is 'Yes' (Type: Electric/Gas toggle, Purchase/Lease toggle, Car Cost, Fuel/Charging, Insurance, Maintenance inputs).
### Details:


## 5. Implement Public Transport Input Fields [done]
### Dependencies: None
### Description: Add the input fields for public transport costs (e.g., Monthly Average, Ride-share Average, Travel Card Costs). These should likely always be visible, regardless of car ownership.
### Details:


## 6. Integrate Transport Module into Page [done]
### Dependencies: None
### Description: Add the TransportModule to app/page.tsx and ensure state is managed correctly (either via context or passed props).
### Details:


## 7. Implement Transport Cost Calculation (Placeholder) [done]
### Dependencies: None
### Description: Create placeholder calculation functions (e.g., in src/utils/calculations/transport.calculations.ts) to sum up the total monthly transport cost based on the inputs.
### Details:




## TASK 011

# Task ID: 11
# Title: Create Lifestyle & Discretionary Costs Module
# Status: done
# Dependencies: 4
# Priority: medium
# Description: Implement the section for lifestyle spending, one-off purchases, travel, and home services.
# Details:
Build input fields for monthly/annual general shopping spend. Create add/remove functionality for one-off big purchases. Include travel & holidays budget input. Add home services section with inputs for cleaner, babysitter, gardening, and pet care. Implement contingency field as fixed amount or percentage of lifestyle total.

# Test Strategy:
Test adding and removing one-off purchases. Verify percentage-based contingency calculations. Ensure all lifestyle costs are correctly summed.

# Subtasks:
## 1. Implement Monthly/Annual General Shopping Spend Input Fields [done]
### Dependencies: None
### Description: Create the input fields for users to enter their monthly and annual general shopping expenditures with appropriate validation and formatting.
### Details:
Implementation steps:
1. Create form components for monthly shopping budget input with currency formatting
2. Add annual shopping budget input with toggle between showing monthly or annual view
3. Implement validation to ensure positive numbers only
4. Add tooltips explaining what should be included in general shopping
5. Store input values in state and ensure they're included in overall calculations
6. Test with various input values, including edge cases like zero values and very large numbers

<info added on 2025-04-16T20:01:55.030Z>
Based on your implementation progress, here's additional information to add to the subtask:

The implementation has been started with a solid foundation. Consider these technical enhancements:

- Extend LifestyleContext.tsx to include specific state types: `interface LifestyleState { generalShoppingSpend: number; isAnnualView: boolean; }` 
- Implement currency formatting using Intl.NumberFormat for consistent display: `new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)`
- Add debounce functionality to input fields to prevent excessive re-renders during user typing
- Ensure the toggle between monthly/annual automatically recalculates values (multiply/divide by 12)
- Implement form validation using React Hook Form or Formik with Yup schema validation
- Add focus and blur event handlers to improve UX when entering currency values
- Consider adding a reset button to clear input values
- Implement proper keyboard accessibility for the frequency toggle component
</info added on 2025-04-16T20:01:55.030Z>

## 2. Build One-Off Big Purchases Add/Remove Functionality [done]
### Dependencies: 11.1
### Description: Create a dynamic interface allowing users to add and remove planned one-off large purchases with details and costs.
### Details:
Implementation steps:
1. Design a form component for adding one-off purchases with fields for item name, cost, and optional date/timeframe
2. Implement an 'Add Purchase' button that creates a new entry in the list
3. Create a display list of added purchases with individual delete buttons
4. Add validation for required fields and proper number formatting
5. Calculate and display the total of all one-off purchases
6. Test adding multiple items, removing items, and ensuring totals update correctly

<info added on 2025-04-16T20:04:37.983Z>
Implementation Plan:
1. Update LifestyleContext.tsx:
   ```typescript
   // Add to state interface
   interface LifestyleState {
     // existing properties
     oneOffPurchases: Array<{
       id: string;
       name: string;
       cost: number;
       targetDate?: string; // optional date field
     }>;
   }

   // Add action types
   type LifestyleAction = 
     // existing actions
     | { type: 'ADD_ONE_OFF_PURCHASE', payload: Omit<OneOffPurchase, 'id'> }
     | { type: 'REMOVE_ONE_OFF_PURCHASE', payload: { id: string } }
     | { type: 'UPDATE_ONE_OFF_PURCHASE', payload: { id: string, updates: Partial<Omit<OneOffPurchase, 'id'>> } };

   // Update reducer
   function lifestyleReducer(state: LifestyleState, action: LifestyleAction): LifestyleState {
     switch (action.type) {
       // existing cases
       case 'ADD_ONE_OFF_PURCHASE':
         return {
           ...state,
           oneOffPurchases: [...state.oneOffPurchases, { id: uuidv4(), ...action.payload }]
         };
       case 'REMOVE_ONE_OFF_PURCHASE':
         return {
           ...state,
           oneOffPurchases: state.oneOffPurchases.filter(item => item.id !== action.payload.id)
         };
       case 'UPDATE_ONE_OFF_PURCHASE':
         return {
           ...state,
           oneOffPurchases: state.oneOffPurchases.map(item => 
             item.id === action.payload.id ? { ...item, ...action.payload.updates } : item
           )
         };
     }
   }
   ```

2. Update LifestyleModule.tsx:
   ```typescript
   const OneOffPurchasesSection = () => {
     const { state, dispatch } = useLifestyleContext();
     const [newPurchase, setNewPurchase] = useState({ name: '', cost: '', targetDate: '' });
     const [errors, setErrors] = useState<{name?: string, cost?: string}>({});
     
     const validateForm = () => {
       const newErrors: {name?: string, cost?: string} = {};
       if (!newPurchase.name.trim()) newErrors.name = 'Name is required';
       if (!newPurchase.cost || isNaN(Number(newPurchase.cost))) newErrors.cost = 'Valid cost is required';
       setErrors(newErrors);
       return Object.keys(newErrors).length === 0;
     };
     
     const handleAddPurchase = () => {
       if (!validateForm()) return;
       
       dispatch({
         type: 'ADD_ONE_OFF_PURCHASE',
         payload: {
           name: newPurchase.name.trim(),
           cost: Number(newPurchase.cost),
           ...(newPurchase.targetDate ? { targetDate: newPurchase.targetDate } : {})
         }
       });
       
       // Reset form
       setNewPurchase({ name: '', cost: '', targetDate: '' });
     };
     
     const totalOneOffCost = state.oneOffPurchases.reduce((sum, item) => sum + item.cost, 0);
     
     return (
       <div className="one-off-purchases-section">
         {/* Form implementation */}
         {/* List of purchases with remove buttons */}
         <div className="purchases-total">
           Total One-Off Purchases: ${totalOneOffCost.toLocaleString()}
         </div>
       </div>
     );
   };
   ```
</info added on 2025-04-16T20:04:37.983Z>

<info added on 2025-04-16T20:05:49.940Z>
<info added on 2025-04-17T14:22:18.000Z>
UI Component Implementation Details:

1. Form Component Structure:
```tsx
const PurchaseForm = () => (
  <div className="purchase-form">
    <div className="form-row">
      <TextField
        label="Purchase Name"
        value={newPurchase.name}
        onChange={(e) => setNewPurchase({...newPurchase, name: e.target.value})}
        error={!!errors.name}
        helperText={errors.name}
        fullWidth
        size="small"
        margin="dense"
      />
    </div>
    <div className="form-row">
      <TextField
        label="Cost ($)"
        value={newPurchase.cost}
        onChange={(e) => setNewPurchase({...newPurchase, cost: e.target.value})}
        error={!!errors.cost}
        helperText={errors.cost}
        type="number"
        InputProps={{
          startAdornment: <InputAdornment position="start">$</InputAdornment>,
        }}
        size="small"
        margin="dense"
      />
      <TextField
        label="Target Date (Optional)"
        type="date"
        value={newPurchase.targetDate}
        onChange={(e) => setNewPurchase({...newPurchase, targetDate: e.target.value})}
        InputLabelProps={{ shrink: true }}
        size="small"
        margin="dense"
      />
    </div>
    <Button 
      variant="contained" 
      color="primary" 
      onClick={handleAddPurchase}
      startIcon={<AddIcon />}
      size="small"
    >
      Add Purchase
    </Button>
  </div>
);
```

2. Purchase List Component:
```tsx
const PurchaseList = () => (
  <div className="purchases-list">
    <Typography variant="subtitle1" gutterBottom>
      Planned One-Off Purchases
    </Typography>
    {state.oneOffPurchases.length === 0 ? (
      <Typography variant="body2" color="textSecondary">
        No purchases added yet
      </Typography>
    ) : (
      <List>
        {state.oneOffPurchases.map((purchase) => (
          <ListItem 
            key={purchase.id}
            secondaryAction={
              <IconButton 
                edge="end" 
                aria-label="delete"
                onClick={() => dispatch({
                  type: 'REMOVE_ONE_OFF_PURCHASE',
                  payload: { id: purchase.id }
                })}
              >
                <DeleteIcon />
              </IconButton>
            }
          >
            <ListItemText
              primary={purchase.name}
              secondary={
                <>
                  ${purchase.cost.toLocaleString()}
                  {purchase.targetDate && ` • Target: ${new Date(purchase.targetDate).toLocaleDateString()}`}
                </>
              }
            />
          </ListItem>
        ))}
      </List>
    )}
    <Divider sx={{ my: 2 }} />
    <Typography variant="h6">
      Total: ${totalOneOffCost.toLocaleString()}
    </Typography>
  </div>
);
```

3. Animation and UX Enhancements:
```tsx
// Add this to your imports
import { CSSTransition, TransitionGroup } from 'react-transition-group';

// Replace the List component with this
<TransitionGroup component={List}>
  {state.oneOffPurchases.map((purchase) => (
    <CSSTransition
      key={purchase.id}
      timeout={300}
      classNames="purchase-item"
    >
      <ListItem>
        {/* ListItem content as before */}
      </ListItem>
    </CSSTransition>
  ))}
</TransitionGroup>

// Add these styles to your CSS
.purchase-item-enter {
  opacity: 0;
  transform: translateY(-10px);
}
.purchase-item-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}
.purchase-item-exit {
  opacity: 1;
}
.purchase-item-exit-active {
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 300ms, transform 300ms;
}
```

4. Input Validation Enhancement:
```typescript
const validateForm = () => {
  const newErrors: {name?: string, cost?: string} = {};
  
  // Name validation
  if (!newPurchase.name.trim()) {
    newErrors.name = 'Name is required';
  } else if (newPurchase.name.trim().length > 50) {
    newErrors.name = 'Name must be 50 characters or less';
  }
  
  // Cost validation
  if (!newPurchase.cost) {
    newErrors.cost = 'Cost is required';
  } else {
    const costValue = Number(newPurchase.cost);
    if (isNaN(costValue)) {
      newErrors.cost = 'Cost must be a valid number';
    } else if (costValue <= 0) {
      newErrors.cost = 'Cost must be greater than zero';
    } else if (costValue > 1000000000) {
      newErrors.cost = 'Cost must be less than 1 billion';
    }
  }
  
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};
```

5. Performance Optimization:
```typescript
// Memoize the total calculation to prevent unnecessary recalculations
const totalOneOffCost = useMemo(() => 
  state.oneOffPurchases.reduce((sum, item) => sum + item.cost, 0),
  [state.oneOffPurchases]
);

// Use callback for handlers to prevent unnecessary re-renders
const handleAddPurchase = useCallback(() => {
  if (!validateForm()) return;
  
  dispatch({
    type: 'ADD_ONE_OFF_PURCHASE',
    payload: {
      name: newPurchase.name.trim(),
      cost: Number(newPurchase.cost),
      ...(newPurchase.targetDate ? { targetDate: newPurchase.targetDate } : {})
    }
  });
  
  // Reset form
  setNewPurchase({ name: '', cost: '', targetDate: '' });
}, [newPurchase, dispatch, validateForm]);
```
</info added on 2025-04-17T14:22:18.000Z>
</info added on 2025-04-16T20:05:49.940Z>

## 3. Create Travel & Holidays Budget Input Section [done]
### Dependencies: 11.1
### Description: Implement the section for users to plan and budget for travel and holiday expenses.
### Details:
Implementation steps:
1. Create input fields for annual travel budget with currency formatting
2. Add optional breakdown fields for different types of travel (weekend trips, major vacations, etc.)
3. Implement a toggle to view monthly equivalent of annual travel budget
4. Add validation for numerical inputs
5. Ensure travel budget is incorporated into the overall lifestyle calculations
6. Test different input combinations and verify correct calculation of totals

<info added on 2025-04-16T20:07:17.346Z>
Implementation Plan:
1. Update LifestyleContext.tsx:
   ```typescript
   // Add to state interface
   interface LifestyleState {
     // existing state properties
     travelHolidaysBudget: {
       amount: number;
       frequency: 'monthly' | 'annual';
       breakdown: {
         weekendTrips: number;
         majorVacations: number;
         holidayCelebrations: number;
         other: number;
       };
     };
   }

   // Add action type
   export const UPDATE_TRAVEL_HOLIDAYS_BUDGET = 'UPDATE_TRAVEL_HOLIDAYS_BUDGET';

   // Add to reducer
   case UPDATE_TRAVEL_HOLIDAYS_BUDGET:
     return {
       ...state,
       travelHolidaysBudget: {
         ...state.travelHolidaysBudget,
         ...action.payload
       }
     };
   ```

2. Create TravelHolidaysBudget.tsx component:
   ```typescript
   import React, { useContext } from 'react';
   import { LifestyleContext, UPDATE_TRAVEL_HOLIDAYS_BUDGET } from '../context/LifestyleContext';
   import { CurrencyInput, Toggle, Accordion } from '../components/ui';

   const TravelHolidaysBudget: React.FC = () => {
     const { state, dispatch } = useContext(LifestyleContext);
     const { travelHolidaysBudget } = state;

     const handleAmountChange = (value: number) => {
       dispatch({
         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,
         payload: { amount: value }
       });
     };

     const handleFrequencyToggle = (frequency: 'monthly' | 'annual') => {
       dispatch({
         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,
         payload: { frequency }
       });
     };

     const handleBreakdownChange = (category: string, value: number) => {
       dispatch({
         type: UPDATE_TRAVEL_HOLIDAYS_BUDGET,
         payload: { 
           breakdown: {
             ...travelHolidaysBudget.breakdown,
             [category]: value
           }
         }
       });
     };

     return (
       <div className="travel-holidays-section">
         <h3>Travel & Holidays Budget</h3>
         <div className="input-row">
           <CurrencyInput
             label="Budget Amount"
             value={travelHolidaysBudget.amount}
             onChange={handleAmountChange}
           />
           <Toggle
             options={[
               { label: 'Monthly', value: 'monthly' },
               { label: 'Annual', value: 'annual' }
             ]}
             value={travelHolidaysBudget.frequency}
             onChange={handleFrequencyToggle}
           />
         </div>
         
         <Accordion title="Budget Breakdown (Optional)">
           <div className="breakdown-inputs">
             {Object.entries(travelHolidaysBudget.breakdown).map(([key, value]) => (
               <CurrencyInput
                 key={key}
                 label={key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                 value={value}
                 onChange={(val) => handleBreakdownChange(key, val)}
               />
             ))}
           </div>
         </Accordion>
         
         {travelHolidaysBudget.frequency === 'annual' && (
           <div className="monthly-equivalent">
             Monthly equivalent: ${(travelHolidaysBudget.amount / 12).toFixed(2)}
           </div>
         )}
       </div>
     );
   };

   export default TravelHolidaysBudget;
   ```

3. Add validation utilities in utils/validation.ts:
   ```typescript
   export const validateTravelBudget = (budget: any) => {
     const errors: Record<string, string> = {};
     
     if (isNaN(budget.amount) || budget.amount < 0) {
       errors.amount = 'Please enter a valid budget amount';
     }
     
     // Validate breakdown values if they exist
     if (budget.breakdown) {
       Object.entries(budget.breakdown).forEach(([key, value]) => {
         if (value !== null && (isNaN(Number(value)) || Number(value) < 0)) {
           errors[`breakdown.${key}`] = 'Please enter a valid amount';
         }
       });
     }
     
     return errors;
   };
   ```
</info added on 2025-04-16T20:07:17.346Z>

<info added on 2025-04-16T20:08:18.681Z>
<info added on 2025-04-17T14:23:45.129Z>
UI Styling and Integration Details:

1. Add these styles to the component:
```css
.travel-holidays-section {
  background-color: var(--card-bg);
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  box-shadow: var(--card-shadow);
}

.breakdown-inputs {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.monthly-equivalent {
  margin-top: 1rem;
  font-size: 0.9rem;
  color: var(--text-secondary);
  font-style: italic;
}
```

2. Integration with LifestyleModule.tsx:
```typescript
// In LifestyleModule.tsx
import TravelHolidaysBudget from './TravelHolidaysBudget';

// Add this to the component's JSX
<div className="lifestyle-module-section">
  <HousingCosts />
  <DailyExpenses />
  <TravelHolidaysBudget /> {/* Add the new component here */}
  {/* Other lifestyle components */}
</div>
```

3. Initialize state in LifestyleContext:
```typescript
// Add to initial state
const initialState: LifestyleState = {
  // existing state
  travelHolidaysBudget: {
    amount: 0,
    frequency: 'annual',
    breakdown: {
      weekendTrips: 0,
      majorVacations: 0,
      holidayCelebrations: 0,
      other: 0
    }
  }
};
```

4. Add calculation utility in utils/calculations.ts:
```typescript
export const calculateMonthlyTravelBudget = (budget: any) => {
  if (!budget || typeof budget.amount !== 'number') {
    return 0;
  }
  
  return budget.frequency === 'monthly' 
    ? budget.amount 
    : budget.amount / 12;
};

// Update the overall monthly expenses calculation
export const calculateTotalMonthlyExpenses = (state: any) => {
  return (
    calculateMonthlyHousingCosts(state.housingCosts) +
    calculateMonthlyDailyExpenses(state.dailyExpenses) +
    calculateMonthlyTravelBudget(state.travelHolidaysBudget) +
    // other expense categories
  );
};
```

5. Add unit tests for the component:
```typescript
// TravelHolidaysBudget.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import TravelHolidaysBudget from './TravelHolidaysBudget';
import { LifestyleProvider } from '../context/LifestyleContext';

describe('TravelHolidaysBudget', () => {
  test('renders the component with initial values', () => {
    render(
      <LifestyleProvider>
        <TravelHolidaysBudget />
      </LifestyleProvider>
    );
    
    expect(screen.getByText('Travel & Holidays Budget')).toBeInTheDocument();
    expect(screen.getByLabelText('Budget Amount')).toHaveValue('0');
    expect(screen.getByText('Annual')).toHaveClass('active');
  });
  
  test('toggles between monthly and annual frequency', () => {
    render(
      <LifestyleProvider>
        <TravelHolidaysBudget />
      </LifestyleProvider>
    );
    
    fireEvent.click(screen.getByText('Monthly'));
    expect(screen.getByText('Monthly')).toHaveClass('active');
    expect(screen.queryByText('Monthly equivalent:')).not.toBeInTheDocument();
    
    fireEvent.click(screen.getByText('Annual'));
    expect(screen.getByText('Annual')).toHaveClass('active');
    expect(screen.getByText(/Monthly equivalent:/)).toBeInTheDocument();
  });
  
  test('updates breakdown values correctly', () => {
    render(
      <LifestyleProvider>
        <TravelHolidaysBudget />
      </LifestyleProvider>
    );
    
    fireEvent.click(screen.getByText('Budget Breakdown (Optional)'));
    
    const weekendTripsInput = screen.getByLabelText('Weekend Trips');
    fireEvent.change(weekendTripsInput, { target: { value: '500' } });
    expect(weekendTripsInput).toHaveValue('500');
  });
});
```
</info added on 2025-04-17T14:23:45.129Z>
</info added on 2025-04-16T20:08:18.681Z>

## 4. Develop Home Services Section with Multiple Service Inputs [done]
### Dependencies: 11.1
### Description: Build the interface for users to input various home service costs including cleaning, childcare, gardening, and pet care.
### Details:
Implementation steps:
1. Create a section with separate input fields for each home service category (cleaner, babysitter, gardening, pet care)
2. For each service, include fields for frequency (weekly, monthly, etc.) and cost per occurrence
3. Calculate and display monthly and annual totals for each service
4. Add an 'Other' category with custom label for additional services
5. Implement validation for all numerical inputs
6. Test calculations with various frequency and cost combinations

<info added on 2025-04-16T20:09:02.576Z>
Implementation Plan:
1. Update LifestyleContext.tsx:
   ```typescript
   // Add to initial state
   homeServices: {
     cleaner: { amount: 0, frequency: 'monthly' },
     babysitter: { amount: 0, frequency: 'weekly' },
     gardening: { amount: 0, frequency: 'monthly' },
     petCare: { amount: 0, frequency: 'monthly' },
     other: { amount: 0, frequency: 'monthly', label: '' }
   }
   
   // Add action type
   export const UPDATE_HOME_SERVICE = 'UPDATE_HOME_SERVICE';
   
   // Add to reducer
   case UPDATE_HOME_SERVICE:
     return {
       ...state,
       homeServices: {
         ...state.homeServices,
         [action.payload.serviceName]: {
           ...state.homeServices[action.payload.serviceName],
           ...action.payload.data
         }
       }
     };
   ```

2. Create HomeServicesSection.tsx component:
   ```typescript
   const frequencies = [
     { value: 'weekly', label: 'Weekly', multiplier: 4.33 },
     { value: 'biweekly', label: 'Bi-weekly', multiplier: 2.17 },
     { value: 'monthly', label: 'Monthly', multiplier: 1 }
   ];
   
   // Include helper function to calculate annual costs
   const calculateAnnualCost = (amount, frequency) => {
     const multiplier = frequencies.find(f => f.value === frequency).multiplier;
     return amount * multiplier * 12;
   };
   ```

3. Implement validation with error handling:
   ```typescript
   const validateAmount = (value) => {
     if (isNaN(value) || value < 0) return 'Please enter a valid amount';
     return null;
   };
   ```

4. Add summary section to display total monthly and annual home service costs across all categories.
</info added on 2025-04-16T20:09:02.576Z>

<info added on 2025-04-16T20:10:29.188Z>
<info added on 2025-04-17T14:32:18.123Z>
Implementation Details:

1. Type definitions for better type safety:
   ```typescript
   // In LifestyleContext.tsx
   export type HomeServiceName = 'cleaner' | 'babysitter' | 'gardening' | 'petCare' | 'other';
   export type HomeServiceFrequency = 'weekly' | 'biweekly' | 'monthly';
   
   export interface HomeServiceEntry {
     amount: number;
     frequency: HomeServiceFrequency;
     label?: string; // Optional for the 'other' category
   }
   
   export interface HomeServicesState {
     [key in HomeServiceName]: HomeServiceEntry;
   }
   ```

2. Helper function for rendering service inputs in LifestyleModule.tsx:
   ```typescript
   const renderServiceInput = (
     serviceName: HomeServiceName, 
     serviceLabel: string, 
     state: LifestyleState, 
     dispatch: React.Dispatch<LifestyleAction>
   ) => {
     const service = state.homeServices[serviceName];
     
     return (
       <div className="service-input-container">
         <label htmlFor={`${serviceName}-amount`}>{serviceLabel}</label>
         <div className="input-group">
           <CurrencyInput
             id={`${serviceName}-amount`}
             value={service.amount}
             onValueChange={(value) => 
               dispatch({
                 type: UPDATE_HOME_SERVICE,
                 payload: {
                   serviceName,
                   data: { amount: value || 0 }
                 }
               })
             }
           />
           <FrequencyToggle
             value={service.frequency}
             onChange={(frequency) => 
               dispatch({
                 type: UPDATE_HOME_SERVICE,
                 payload: {
                   serviceName,
                   data: { frequency }
                 }
               })
             }
           />
         </div>
         <div className="cost-summary">
           <span>Monthly: ${calculateMonthlyCost(service.amount, service.frequency)}</span>
           <span>Yearly: ${calculateAnnualCost(service.amount, service.frequency)}</span>
         </div>
       </div>
     );
   };
   ```

3. FrequencyToggle component implementation:
   ```typescript
   const FrequencyToggle: React.FC<{
     value: HomeServiceFrequency;
     onChange: (frequency: HomeServiceFrequency) => void;
   }> = ({ value, onChange }) => {
     return (
       <div className="frequency-toggle">
         {frequencies.map(freq => (
           <button
             key={freq.value}
             className={value === freq.value ? 'active' : ''}
             onClick={() => onChange(freq.value as HomeServiceFrequency)}
           >
             {freq.label}
           </button>
         ))}
       </div>
     );
   };
   ```

4. Custom input for "Other" category:
   ```typescript
   const renderOtherServiceInput = (state, dispatch) => {
     const service = state.homeServices.other;
     
     return (
       <div className="service-input-container">
         <div className="other-service-header">
           <input
             type="text"
             placeholder="Other service..."
             value={service.label || ''}
             onChange={(e) => 
               dispatch({
                 type: UPDATE_HOME_SERVICE,
                 payload: {
                   serviceName: 'other',
                   data: { label: e.target.value }
                 }
               })
             }
           />
         </div>
         {/* Rest of input similar to renderServiceInput */}
       </div>
     );
   };
   ```

5. Total calculation function:
   ```typescript
   const calculateTotalHomeServices = (homeServices: HomeServicesState) => {
     let monthlyTotal = 0;
     let annualTotal = 0;
     
     Object.values(homeServices).forEach(service => {
       if (service.amount) {
         const monthly = calculateMonthlyCost(service.amount, service.frequency);
         monthlyTotal += monthly;
         annualTotal += monthly * 12;
       }
     });
     
     return { monthlyTotal, annualTotal };
   };
   ```

6. CSS for the home services section:
   ```css
   .home-services-section {
     display: flex;
     flex-direction: column;
     gap: 1.5rem;
   }
   
   .service-input-container {
     padding: 1rem;
     border-radius: 8px;
     background-color: var(--color-background-light);
     box-shadow: 0 1px 3px rgba(0,0,0,0.1);
   }
   
   .frequency-toggle {
     display: flex;
     border-radius: 4px;
     overflow: hidden;
   }
   
   .frequency-toggle button {
     flex: 1;
     padding: 0.5rem;
     border: 1px solid var(--color-border);
     background: none;
     cursor: pointer;
   }
   
   .frequency-toggle button.active {
     background-color: var(--color-primary);
     color: white;
   }
   
   .cost-summary {
     display: flex;
     justify-content: space-between;
     margin-top: 0.5rem;
     font-size: 0.9rem;
     color: var(--color-text-secondary);
   }
   ```
</info added on 2025-04-17T14:32:18.123Z>
</info added on 2025-04-16T20:10:29.188Z>

## 5. Implement Contingency Field with Percentage/Fixed Amount Options [done]
### Dependencies: 11.1, 11.2, 11.3, 11.4
### Description: Create functionality for users to add a contingency amount either as a fixed sum or as a percentage of total lifestyle costs.
### Details:
Implementation steps:
1. Create a toggle between 'Fixed Amount' and 'Percentage' options for contingency
2. For fixed amount, add a currency-formatted input field
3. For percentage, add a percentage input with preview of calculated amount
4. Calculate the total lifestyle costs from all previous sections
5. Add the contingency amount to the total and display both the contingency and grand total
6. Test both percentage and fixed amount modes with various inputs
7. Verify contingency updates correctly when any lifestyle cost changes

<info added on 2025-04-16T20:11:01.571Z>
Implementation Plan:
1. Update LifestyleContext.tsx:
   ```typescript
   // Add to state interface
   interface LifestyleState {
     // existing state properties
     contingency: {
       type: 'fixed' | 'percentage';
       value: number;
     };
   }
   
   // Add action type
   export const UPDATE_CONTINGENCY = 'UPDATE_CONTINGENCY';
   
   // Add action interface
   interface UpdateContingencyAction {
     type: typeof UPDATE_CONTINGENCY;
     payload: {
       type: 'fixed' | 'percentage';
       value: number;
     };
   }
   
   // Update reducer
   case UPDATE_CONTINGENCY:
     return {
       ...state,
       contingency: action.payload
     };
   ```

2. Update LifestyleModule.tsx:
   ```typescript
   const ContingencySection = () => {
     const { state, dispatch } = useLifestyleContext();
     const baseLifestyleCost = calculateTotalMonthlyLifestyleCosts(state);
     
     const handleTypeChange = (type: 'fixed' | 'percentage') => {
       dispatch({
         type: UPDATE_CONTINGENCY,
         payload: { type, value: state.contingency.value }
       });
     };
     
     const handleValueChange = (value: number) => {
       dispatch({
         type: UPDATE_CONTINGENCY,
         payload: { type: state.contingency.type, value }
       });
     };
     
     const contingencyAmount = state.contingency.type === 'fixed' 
       ? state.contingency.value 
       : (baseLifestyleCost * state.contingency.value / 100);
     
     return (
       <Section title="Contingency">
         <ToggleButtonGroup
           value={state.contingency.type}
           exclusive
           onChange={(_, value) => handleTypeChange(value)}
         >
           <ToggleButton value="fixed">Fixed Amount</ToggleButton>
           <ToggleButton value="percentage">Percentage</ToggleButton>
         </ToggleButtonGroup>
         
         {state.contingency.type === 'fixed' ? (
           <CurrencyInput
             value={state.contingency.value}
             onChange={handleValueChange}
             label="Contingency Amount"
           />
         ) : (
           <Box>
             <PercentageInput
               value={state.contingency.value}
               onChange={handleValueChange}
               label="Contingency Percentage"
             />
             <Typography variant="body2">
               {formatCurrency(contingencyAmount)} ({state.contingency.value}% of {formatCurrency(baseLifestyleCost)})
             </Typography>
           </Box>
         )}
         
         <Typography variant="subtitle1" sx={{ mt: 2 }}>
           Total with Contingency: {formatCurrency(baseLifestyleCost + contingencyAmount)}
         </Typography>
       </Section>
     );
   };
   
   // Helper function to calculate total monthly lifestyle costs
   const calculateTotalMonthlyLifestyleCosts = (state: LifestyleState) => {
     const generalShoppingTotal = calculateMonthlyEquivalent(state.generalShopping);
     const oneOffsTotal = calculateMonthlyEquivalent(state.oneOffs);
     const travelTotal = calculateMonthlyEquivalent(state.travel);
     const homeServicesTotal = calculateMonthlyEquivalent(state.homeServices);
     
     return generalShoppingTotal + oneOffsTotal + travelTotal + homeServicesTotal;
   };
   ```
</info added on 2025-04-16T20:11:01.571Z>

<info added on 2025-04-16T20:12:23.576Z>
<info added on 2025-04-17T14:23:45.000Z>
Implementation Notes:

1. Edge Case Handling:
   ```typescript
   // Add validation to prevent negative values
   const handleValueChange = (value: number) => {
     const sanitizedValue = Math.max(0, value); // Prevent negative values
     dispatch({
       type: UPDATE_CONTINGENCY,
       payload: { type: state.contingency.type, value: sanitizedValue }
     });
   };
   ```

2. Performance Optimization:
   ```typescript
   // Memoize the base lifestyle cost calculation to prevent unnecessary recalculations
   const baseLifestyleCost = useMemo(() => 
     calculateTotalMonthlyLifestyleCosts(state), 
     [state.generalShopping, state.oneOffs, state.travel, state.homeServices]
   );
   ```

3. Accessibility Improvements:
   ```typescript
   <ToggleButtonGroup
     value={state.contingency.type}
     exclusive
     onChange={(_, value) => handleTypeChange(value)}
     aria-label="contingency calculation method"
   >
     <ToggleButton value="fixed" aria-label="fixed amount">Fixed Amount</ToggleButton>
     <ToggleButton value="percentage" aria-label="percentage">Percentage</ToggleButton>
   </ToggleButtonGroup>
   ```

4. Default State Initialization:
   ```typescript
   // In initialState
   contingency: {
     type: 'percentage', // Default to percentage
     value: 10 // Default to 10%
   }
   ```

5. Unit Tests:
   ```typescript
   // ContingencySection.test.tsx
   test('updates contingency correctly when base costs change', () => {
     // Setup with mock state and dispatch
     // Render component
     // Update a lifestyle cost category
     // Verify contingency amount updates correctly
   });

   test('switches between fixed and percentage modes correctly', () => {
     // Setup with initial percentage mode
     // Render component
     // Click fixed amount toggle
     // Verify input field changes appropriately
     // Verify calculated amount updates correctly
   });
   ```

6. Debounce Implementation:
   ```typescript
   // Add debounce to prevent excessive recalculations during rapid input changes
   const debouncedHandleValueChange = useCallback(
     debounce((value: number) => {
       handleValueChange(value);
     }, 300),
     [state.contingency.type]
   );
   ```
</info added on 2025-04-17T14:23:45.000Z>
</info added on 2025-04-16T20:12:23.576Z>



## TASK 012

# Task ID: 12
# Title: Build Utilities Module
# Status: done
# Dependencies: 4
# Priority: medium
# Description: Create the utilities section for electricity, water, gas/heating, internet, and mobile costs.
# Details:
Implement input fields for monthly utility costs including electricity, water, gas/heating. Add internet & mobile cost inputs. Calculate monthly averages and totals. Consider seasonal variations option for utilities like heating.

# Test Strategy:
Verify that all utility inputs are correctly captured and summed. Test that monthly averages are calculated correctly.

# Subtasks:
## 1. Create Basic Utilities Input Form Structure [done]
### Dependencies: None
### Description: Build the core UI structure for the utilities module with input fields for all required utility types
### Details:
Implementation details:
1. Create a new component called 'UtilitiesModule'
2. Design a form layout with separate sections for each utility type (electricity, water, gas/heating, internet, mobile)
3. Implement input fields for each utility with appropriate labels and validation
4. Add currency formatting and input validation for monetary values
5. Create state management for storing input values
6. Add a basic monthly total calculation that sums all utility inputs
7. Style the component according to the application's design system

Testing approach:
- Verify all input fields render correctly
- Test input validation for negative numbers and non-numeric inputs
- Confirm the monthly total updates correctly when values change

<info added on 2025-04-16T21:17:57.390Z>
Implementation Plan:
1. Create a new file `UtilitiesModule.tsx` in the components directory.
2. Define interface `UtilitiesProps` type with properties: `electricity: string, water: string, gasHeating: string, internet: string, mobile: string, onUtilitiesChange: (field: string, value: string) => void`.
3. Use DaisyUI/Tailwind components (`card`, `card-body`, `form-control`, `input`) for layout, similar to existing form components.
4. Add `CurrencyInput` component for each utility field (Electricity, Water, Gas/Heating, Internet, Mobile), binding value to props and onChange to onUtilitiesChange handler.
5. Calculate the sum of all utility prop values (converting to numbers) and display it formatted as currency (€ XXX.XX) in a dedicated section with a distinct visual style.
6. Export the component as default for easy importing.
7. Implement a helper function `validateUtilityInput` to ensure only valid numeric values are accepted.
8. Add responsive design considerations to ensure the form works well on mobile devices.
</info added on 2025-04-16T21:17:57.390Z>

<info added on 2025-04-16T21:18:08.263Z>
<info added>
Implementation Plan:
1. Create a new file `UtilitiesModule.tsx` in the components directory.
2. Define interface `UtilitiesProps` type with properties: `electricity: string, water: string, gasHeating: string, internet: string, mobile: string, onUtilitiesChange: (field: string, value: string) => void`.
3. Use DaisyUI/Tailwind components (`card`, `card-body`, `form-control`, `input`) for layout, similar to existing form components.
4. Add `CurrencyInput` component for each utility field (Electricity, Water, Gas/Heating, Internet, Mobile), binding value to props and onChange to onUtilitiesChange handler.
5. Calculate the sum of all utility prop values (converting to numbers) and display it formatted as currency (€ XXX.XX) in a dedicated section with a distinct visual style.
6. Export the component as default for easy importing.
7. Implement a helper function `validateUtilityInput` to ensure only valid numeric values are accepted.
8. Add responsive design considerations to ensure the form works well on mobile devices.
</info added>
</info added on 2025-04-16T21:18:08.263Z>

## 2. Implement Seasonal Variation Options [done]
### Dependencies: 12.1
### Description: Add functionality to account for seasonal variations in utility costs
### Details:
Implementation details:
1. Extend the UtilitiesModule to include toggles for enabling seasonal variations for applicable utilities (primarily electricity and gas/heating)
2. When seasonal variation is enabled for a utility, display input fields for each season (Winter, Spring, Summer, Fall) or allow monthly inputs
3. Implement logic to calculate the annual average based on seasonal inputs
4. Update the monthly calculation to use seasonal values when available
5. Add visual indicators showing which utilities have seasonal variations enabled
6. Implement data validation for seasonal inputs

Testing approach:
- Test toggling seasonal variations on/off for different utilities
- Verify calculations correctly average seasonal values
- Confirm the UI adapts appropriately when seasonal mode is enabled/disabled

<info added on 2025-04-16T21:25:18.024Z>
Here's the additional implementation information:

```typescript
// 1. Extended UtilitiesProps interface
interface UtilitiesProps {
  // Existing props
  isSeasonalElectricity: boolean;
  isSeasonalGasHeating: boolean;
  electricityWinter: number;
  electricitySpring: number;
  electricitySummer: number;
  electricityFall: number;
  gasHeatingWinter: number;
  gasHeatingSpring: number;
  gasHeatingSummer: number;
  gasHeatingFall: number;
  // ...other props
}

// 2. Toggle component implementation
const SeasonalToggle = ({ isEnabled, onChange, label }) => (
  <div className="form-control">
    <label className="label cursor-pointer">
      <span className="label-text">{label}</span>
      <input 
        type="checkbox" 
        className="toggle toggle-primary" 
        checked={isEnabled} 
        onChange={e => onChange(e.target.checked)} 
      />
    </label>
  </div>
);

// 3. Seasonal inputs rendering logic
{isSeasonalElectricity ? (
  <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
    <InputField label="Winter" value={electricityWinter} onChange={val => handleSeasonalChange('electricityWinter', val)} />
    <InputField label="Spring" value={electricitySpring} onChange={val => handleSeasonalChange('electricitySpring', val)} />
    <InputField label="Summer" value={electricitySummer} onChange={val => handleSeasonalChange('electricitySummer', val)} />
    <InputField label="Fall" value={electricityFall} onChange={val => handleSeasonalChange('electricityFall', val)} />
  </div>
) : (
  <InputField label="Monthly" value={electricity} onChange={val => handleChange('electricity', val)} />
)}

// 4. Calculation function for seasonal averaging
const calculateSeasonalAverage = (winter, spring, summer, fall) => {
  return (winter + spring + summer + fall) / 4;
};

// 5. Update to calculateTotal function
const calculateTotal = () => {
  const electricityCost = isSeasonalElectricity 
    ? calculateSeasonalAverage(electricityWinter, electricitySpring, electricitySummer, electricityFall)
    : electricity;
  
  const gasHeatingCost = isSeasonalGasHeating
    ? calculateSeasonalAverage(gasHeatingWinter, gasHeatingSpring, gasHeatingSummer, gasHeatingFall)
    : gasHeating;
    
  // Continue with other utilities and return total
};
```

Include visual indicators next to seasonal toggles using a small badge or icon that shows "Seasonal" when enabled. Add validation to ensure all seasonal inputs are valid numbers and provide appropriate error messages.
</info added on 2025-04-16T21:25:18.024Z>

## 3. Integrate Utilities Module with Budget System [done]
### Dependencies: 12.1, 12.2
### Description: Connect the utilities module to the overall budget system and implement advanced calculations
### Details:
Implementation details:
1. Create a data service to handle utilities data persistence
2. Implement methods to save and retrieve utilities data
3. Connect the utilities module to the main budget calculation system
4. Add summary statistics for utilities (percentage of total budget, year-over-year comparisons if historical data exists)
5. Implement a utilities dashboard widget showing key metrics
6. Add export functionality for utilities data
7. Implement comparison features to benchmark against average utility costs

Testing approach:
- Verify data persistence works correctly
- Test integration with the main budget system
- Confirm summary statistics calculate correctly
- Validate that the utilities data appears correctly in reports and dashboards

<info added on 2025-04-16T21:26:37.360Z>
For the core integration with the budget system, here's a more detailed implementation plan:

```javascript
// In src/app/page.tsx
const [utilitiesState, setUtilitiesState] = useState({
  electricity: { monthly: 0, seasonal: false, winter: 0, summer: 0 },
  water: { monthly: 0, seasonal: false, winter: 0, summer: 0 },
  gas: { monthly: 0, seasonal: false, winter: 0, summer: 0 },
  internet: { monthly: 0 },
  phone: { monthly: 0 },
  other: { monthly: 0 }
});

const handleUtilitiesChange = (category, field, value) => {
  setUtilitiesState(prev => ({
    ...prev,
    [category]: {
      ...prev[category],
      [field]: value
    }
  }));
};

// Calculate total utilities cost for budget summary
const calculateUtilitiesTotals = () => {
  let annualTotal = 0;
  
  Object.keys(utilitiesState).forEach(utility => {
    const item = utilitiesState[utility];
    if (item.seasonal) {
      // 6 months of each season
      annualTotal += (item.winter * 6) + (item.summer * 6);
    } else {
      annualTotal += item.monthly * 12;
    }
  });
  
  return {
    monthly: annualTotal / 12,
    annual: annualTotal
  };
};

// Pass to BudgetSummaryDisplay
const utilityTotals = calculateUtilitiesTotals();
```

Include a simple context provider to avoid prop drilling if the component hierarchy becomes complex:

```javascript
// src/contexts/UtilitiesContext.js
import { createContext, useContext } from 'react';

const UtilitiesContext = createContext();

export const useUtilities = () => useContext(UtilitiesContext);

export const UtilitiesProvider = ({ children, value }) => (
  <UtilitiesContext.Provider value={value}>
    {children}
  </UtilitiesContext.Provider>
);
```
</info added on 2025-04-16T21:26:37.360Z>



## TASK 013

# Task ID: 13
# Title: Implement Education Module
# Status: done
# Dependencies: 4, 6
# Priority: medium
# Description: Build the education section with public/private toggle and associated costs.
# Details:
Create public/private education toggle for each child in the household. For private education, include annual tuition input and show monthly payment breakdown. Add fields for extra school costs like books, uniforms, and activities. Calculate education totals per child and household.

# Test Strategy:
Test that education options appear correctly based on household composition. Verify calculations for monthly payment breakdowns from annual tuition.

# Subtasks:
## 1. Create Education Type Toggle and Basic Structure [done]
### Dependencies: None
### Description: Implement the core education module structure with public/private education toggle for each child
### Details:
Implementation steps:
1. Create an Education component that integrates with the existing household data structure
2. Add a public/private toggle switch for each child in the household
3. Implement conditional rendering based on the education type selection
4. Store education type selection in state for each child
5. Create the basic layout structure for the education module
6. Add validation to ensure each child has an education type selected

Testing approach:
- Verify the toggle works correctly for each child
- Confirm the UI updates appropriately when switching between public and private
- Test with various household compositions (different numbers of children)
- Ensure state is properly maintained when navigating between sections

<info added on 2025-04-16T21:38:01.533Z>
I've reviewed the implementation and can provide these additional technical details:

For the Education.tsx component:
- Use a Map structure like `Map<string, 'public' | 'private'>` for the education type state to ensure type safety
- Implement the toggle using the existing design system's Toggle component with proper ARIA attributes
- Add data-testid attributes (e.g., `data-testid="education-toggle-primary-0"`) to facilitate testing

State management improvements:
- Structure the state object as `{[childId: string]: {educationType: 'public' | 'private', gradeLevel?: string}}` to accommodate future education details
- Use React.useReducer instead of useState for more predictable state transitions when handling multiple children

Validation implementation:
- Add form validation using the existing validation framework
- Create a validateEducation() function that returns error messages for any child missing an education type
- Connect validation to the "Continue" button's onClick handler

For conditional rendering:
- Implement a getEducationFormByType(type: 'public' | 'private', childData) function that returns the appropriate form components
- Use React.memo to prevent unnecessary re-renders when toggling between children
</info added on 2025-04-16T21:38:01.533Z>

## 2. Implement Private Education Cost Inputs [done]
### Dependencies: 13.1
### Description: Add tuition and additional education cost input fields for children with private education
### Details:
Implementation steps:
1. Create input fields for annual tuition costs that appear only when private education is selected
2. Add input fields for additional education expenses (books, uniforms, activities, etc.)
3. Implement proper number formatting and validation for all cost inputs
4. Create helper functions to convert annual costs to monthly amounts
5. Store all education cost data in the application state
6. Ensure inputs have appropriate labels and help text

Testing approach:
- Test input validation for all fields (negative numbers, non-numeric input, etc.)
- Verify conditional rendering works correctly based on education type
- Test data persistence when switching between children or sections
- Confirm proper number formatting for currency inputs

<info added on 2025-04-16T21:43:19.219Z>
For the "Implement Private Education Cost Inputs" subtask:

The implementation in Education.tsx uses React's conditional rendering with the ternary operator to show/hide tuition fields based on the `educationType` state value. Cost input fields are wrapped in a `CostInputGroup` component that handles formatting and validation.

State management updates in page.tsx include:
```typescript
interface EducationCosts {
  annualTuition: number;
  books: number;
  uniforms: number;
  activities: number;
  other: number;
}

interface ChildEducation {
  type: 'public' | 'private' | 'homeschool';
  costs: EducationCosts;
}
```

Number formatting utilities in utils/formatting.ts:
```typescript
export const formatCurrency = (value: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(value);
};

export const parseInputToNumber = (input: string): number => {
  return Number(input.replace(/[^0-9.-]+/g, ''));
};
```

Added monthly calculation helper:
```typescript
export const calculateMonthlyFromAnnual = (annualAmount: number): number => {
  return annualAmount / 12;
};
```
</info added on 2025-04-16T21:43:19.219Z>

## 3. Calculate and Display Education Cost Summaries [done]
### Dependencies: 13.1, 13.2
### Description: Implement calculations for per-child and household education totals with monthly breakdown
### Details:
Implementation steps:
1. Create functions to calculate total education costs per child (tuition + additional costs)
2. Implement monthly payment breakdown calculations for each child
3. Add a summary section showing education costs per child
4. Calculate and display total household education expenses
5. Integrate education totals with the overall household budget calculations
6. Add visual elements (charts or tables) to display the education cost breakdown

Testing approach:
- Verify calculations are correct for various input scenarios
- Test with multiple children having different education types
- Confirm monthly breakdowns are calculated correctly
- Check that household totals accurately reflect the sum of all children's education costs
- Test integration with the overall budget summary

<info added on 2025-04-16T22:11:03.307Z>
For the Education.tsx component, I've implemented the calculation logic using React's useMemo hook for performance optimization. Here's the specific implementation:

```tsx
// Education cost calculation using useMemo for performance
const educationCosts = useMemo(() => {
  return children.map(child => {
    const tuition = parseFloat(child.tuition || '0');
    const additionalCosts = parseFloat(child.additionalCosts || '0');
    const annualTotal = tuition + additionalCosts;
    const monthlyTotal = annualTotal / 12;
    
    return {
      childId: child.id,
      childName: child.name,
      annualTuition: tuition,
      annualAdditionalCosts: additionalCosts,
      annualTotal,
      monthlyTotal
    };
  });
}, [children]);

// Calculate household totals
const householdTotals = useMemo(() => {
  const annual = educationCosts.reduce((sum, child) => sum + child.annualTotal, 0);
  return {
    annual,
    monthly: annual / 12
  };
}, [educationCosts]);
```

Added a summary section at the bottom of the Education card:

```tsx
<Box mt={4} p={3} bgcolor="rgba(0,0,0,0.03)" borderRadius={1}>
  <Typography variant="h6" gutterBottom>Education Cost Summary</Typography>
  <Grid container spacing={2}>
    {educationCosts.map(child => (
      <Grid item xs={12} sm={6} md={4} key={child.childId}>
        <Paper elevation={1} sx={{ p: 2 }}>
          <Typography variant="subtitle1">{child.childName}</Typography>
          <Typography>Monthly: ${child.monthlyTotal.toFixed(2)}</Typography>
          <Typography>Annual: ${child.annualTotal.toFixed(2)}</Typography>
        </Paper>
      </Grid>
    ))}
    <Grid item xs={12}>
      <Paper elevation={2} sx={{ p: 2, bgcolor: "primary.light", color: "primary.contrastText" }}>
        <Typography variant="h6">Household Education Totals</Typography>
        <Typography variant="h5">${householdTotals.monthly.toFixed(2)}/month</Typography>
        <Typography>${householdTotals.annual.toFixed(2)}/year</Typography>
      </Paper>
    </Grid>
  </Grid>
</Box>
```

Implemented conditional display of per-child monthly costs in the child education form:

```tsx
{child.tuition && child.tuition !== '0' && (
  <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
    Monthly cost: ${(parseFloat(child.tuition || '0') / 12).toFixed(2)}
  </Typography>
)}
```
</info added on 2025-04-16T22:11:03.307Z>



## TASK 014

# Task ID: 14
# Title: Develop Healthcare Module
# Status: done
# Dependencies: 4, 6
# Priority: medium
# Description: Create the healthcare section with coverage type and cost inputs.
# Details:
Implement healthcare type selection (Public, Private, Hybrid) for each household member. Include monthly premium inputs for private options. Add estimated out-of-pocket expense fields for GP visits, dental, and prescriptions. Include section for known recurring medical costs.

# Test Strategy:
Test that healthcare options appear for each household member. Verify healthcare cost calculations are correct based on selected options.

# Subtasks:
## 1. Create Healthcare Coverage Type Selection Component [done]
### Dependencies: None
### Description: Develop a component that allows users to select healthcare coverage type (Public, Private, Hybrid) for each household member
### Details:
Implementation details:
1. Create a new component called 'HealthcareCoverageSelector'
2. Implement a dropdown selection for coverage types (Public, Private, Hybrid)
3. Design the component to be reusable for each household member
4. Add validation to ensure a selection is made
5. Connect the component to the household member data structure
6. Include conditional rendering that shows premium input fields only when Private or Hybrid is selected
7. Style the component according to the application's design system

Testing approach:
- Verify all three options appear in the dropdown
- Test that the component correctly associates selections with the right household member
- Confirm conditional fields appear/disappear based on selection
- Test validation behavior when no selection is made

## 2. Implement Out-of-Pocket Expense Estimation Fields [done]
### Dependencies: 14.1
### Description: Create input fields for estimating out-of-pocket healthcare expenses including GP visits, dental, and prescriptions
### Details:
Implementation details:
1. Create a new component called 'OutOfPocketExpenseEstimator'
2. Implement separate numeric input fields for:
   - GP visit costs (per visit and estimated annual frequency)
   - Dental expenses (routine and special procedures)
   - Prescription medications (monthly estimate)
3. Add validation for numeric inputs (positive numbers only)
4. Calculate and display estimated annual totals for each category
5. Implement a summary section showing total estimated annual out-of-pocket expenses
6. Connect these fields to the household member data structure
7. Ensure proper currency formatting for all monetary values

Testing approach:
- Test input validation for negative numbers and non-numeric entries
- Verify calculations are correct for annual totals
- Test that data is properly saved to the household member record
- Check currency formatting across different expense amounts

## 3. Develop Recurring Medical Costs Tracker [done]
### Dependencies: 14.1, 14.2
### Description: Create a section for tracking known recurring medical costs and integrate the entire healthcare module with the household data structure
### Details:
Implementation details:
1. Create a 'RecurringMedicalCostsTracker' component with:
   - Ability to add multiple recurring costs (name, amount, frequency)
   - Option to specify which household member the cost applies to
   - Delete and edit functionality for existing entries
2. Implement a summary view showing total recurring costs per month/year
3. Integrate all healthcare components (coverage selection, out-of-pocket estimator, recurring costs) into a cohesive Healthcare Module
4. Connect the complete module to the main application's state management
5. Implement data persistence for all healthcare-related inputs
6. Add a summary dashboard showing total healthcare costs across all household members
7. Ensure the module works with the existing household member management system

Testing approach:
- Test adding, editing, and removing recurring costs
- Verify calculations for different frequency options (weekly, monthly, quarterly, annually)
- Test the integration with the main application state
- Verify data persistence works correctly
- Test the complete healthcare module with multiple household members having different healthcare scenarios



## TASK 015

# Task ID: 15
# Title: Build Emergency Buffer Calculator
# Status: done
# Dependencies: 8, 9, 10, 11, 12, 13, 14
# Priority: medium
# Description: Implement the emergency savings buffer calculator with runway visualization.
# Details:
Create inputs for target number of months of coverage and current reserve amount. Calculate fixed expenses from previously entered data. Implement a visual runway meter showing months of financial coverage. Add recommendations based on common financial advice.

# Test Strategy:
Test that fixed expenses are correctly pulled from other modules. Verify runway calculation accuracy. Ensure the visual meter updates correctly based on inputs.

# Subtasks:
## 1. Create Data Model for Emergency Buffer Calculator [done]
### Dependencies: None
### Description: Define the data structure to store emergency buffer information including target months, current reserve amount, and fixed expenses.
### Details:
Implementation steps:
1. Create a new EmergencyBufferModel class with properties for targetMonths, currentReserve, and fixedExpenses
2. Add methods to calculate total monthly fixed expenses
3. Add method to calculate current runway (months of coverage)
4. Implement data validation for inputs
5. Create unit tests to verify calculations

Testing approach:
- Test calculation accuracy with various input combinations
- Verify edge cases (zero expenses, zero reserve, etc.)
- Ensure proper data validation

## 2. Implement Fixed Expense Aggregation from Existing Data [done]
### Dependencies: 15.1
### Description: Create functionality to aggregate and calculate fixed monthly expenses from previously entered financial data.
### Details:
Implementation steps:
1. Create a service to fetch existing expense data from other modules
2. Implement logic to filter and identify fixed expenses
3. Calculate total monthly fixed expenses
4. Add caching mechanism to avoid recalculating when expense data hasn't changed
5. Connect this service to the EmergencyBufferModel

Testing approach:
- Mock expense data sources for testing
- Verify correct identification of fixed expenses
- Test aggregation with various expense scenarios
- Ensure proper error handling for missing data

## 3. Build User Interface for Emergency Buffer Inputs [done]
### Dependencies: 15.1
### Description: Create the UI components for users to input target months of coverage and current reserve amount.
### Details:
Implementation steps:
1. Create form inputs for target months (slider or number input)
2. Add input for current emergency reserve amount
3. Implement real-time validation with appropriate feedback
4. Connect inputs to the EmergencyBufferModel
5. Add help text explaining each input's purpose

Testing approach:
- Test input validation for various scenarios
- Verify UI updates when model changes
- Test accessibility compliance
- Ensure responsive design works on different screen sizes

## 4. Develop Runway Visualization Component [done]
### Dependencies: 15.1, 15.2, 15.3
### Description: Create a visual meter showing months of financial coverage based on current reserve and fixed expenses.
### Details:
Implementation steps:
1. Design a visual meter component (progress bar, gauge, etc.)
2. Implement color coding based on coverage status (red for < 3 months, yellow for 3-5, green for 6+)
3. Add animations for transitions between states
4. Display numeric values alongside visual representation
5. Ensure the visualization updates when inputs change

Testing approach:
- Test rendering with different data scenarios
- Verify color changes at appropriate thresholds
- Test animation behavior
- Ensure accessibility for color-blind users (include text indicators)

## 5. Implement Recommendation Engine [done]
### Dependencies: 15.1, 15.2, 15.4
### Description: Create a system to generate personalized recommendations based on the user's emergency buffer status and common financial advice.
### Details:
Implementation steps:
1. Define a set of recommendation rules based on financial best practices
2. Implement logic to select appropriate recommendations based on:
   - Current runway vs target months
   - Fixed expense ratio to income
   - Current savings rate
3. Create UI components to display recommendations
4. Add links to educational resources for each recommendation
5. Implement priority sorting for recommendations

Testing approach:
- Test recommendation generation with various financial scenarios
- Verify correct prioritization of advice
- Test UI rendering of recommendations
- Ensure recommendations are actionable and clear



## TASK 016

# Task ID: 16
# Title: Implement FX Sensitivity Module
# Status: done
# Dependencies: 3, 8
# Priority: medium
# Description: Create the foreign exchange sensitivity analysis tools.
# Details:
Build exchange rate override input that defaults to API values. Implement FX movement sliders or percentage shock simulation. Create visualizations showing impact of FX changes on budget. Ensure all modules display dual-currency output (origin vs. destination).

# Test Strategy:
Test that manual overrides work correctly. Verify that FX changes propagate through all calculations. Test edge cases with extreme exchange rate values.

# Subtasks:
## 1. Create Exchange Rate API Integration Service [done]
### Dependencies: None
### Description: Develop a service to fetch and manage foreign exchange rates from an external API, with caching capabilities and error handling.
### Details:
Implementation details:
1. Create a service class that handles API calls to fetch current exchange rates
2. Implement caching mechanism to store rates for configurable time periods
3. Add error handling for API failures with fallback to cached values
4. Create methods to convert between currencies using the fetched rates
5. Add logging for rate updates and conversion operations
6. Testing approach: Write unit tests with mocked API responses, test caching behavior, and verify conversion calculations

## 2. Build Exchange Rate Override UI Component [done]
### Dependencies: 16.1
### Description: Create a user interface component allowing users to view current exchange rates and manually override them with custom values.
### Details:
Implementation details:
1. Design a UI component showing current exchange rates from the API service
2. Add input fields for manual rate overrides with validation
3. Implement toggle switches to enable/disable specific rate overrides
4. Create visual indicators showing which rates are using API values vs overrides
5. Add reset functionality to revert to API values
6. Testing approach: Create component tests verifying UI rendering, input validation, and proper state management for overrides

## 3. Implement FX Movement Simulation Controls [done]
### Dependencies: 16.1, 16.2
### Description: Develop slider controls and percentage input fields that allow users to simulate currency value fluctuations.
### Details:
Implementation details:
1. Create slider components with appropriate ranges for FX movement simulation
2. Add percentage input fields synchronized with slider positions
3. Implement bidirectional binding between sliders and input fields
4. Add presets for common shock scenarios (e.g., 5%, 10%, 15% movements)
5. Create a reset button to return all simulations to baseline
6. Testing approach: Test slider-input synchronization, boundary values, and preset functionality through component tests

## 4. Develop FX Impact Calculation Engine [done]
### Dependencies: 16.1, 16.3
### Description: Create the core calculation logic to determine how exchange rate changes affect budget figures across the application.
### Details:
Implementation details:
1. Develop algorithms to recalculate budget values based on exchange rate changes
2. Create a calculation pipeline that processes all budget items with the simulated rates
3. Implement delta calculations to show differences between baseline and simulated scenarios
4. Add percentage and absolute change calculations for key metrics
5. Optimize for performance with large datasets
6. Testing approach: Write comprehensive unit tests with various exchange rate scenarios, verify calculations against manually verified examples

## 5. Create FX Impact Visualizations [done]
### Dependencies: 16.4
### Description: Develop charts and visual representations showing the impact of exchange rate changes on budget items.
### Details:
Implementation details:
1. Design and implement bar/column charts showing before/after values for key budget items
2. Create heat maps highlighting areas most sensitive to FX changes
3. Develop waterfall charts showing cumulative impact across categories
4. Add interactive tooltips with detailed information on hover
5. Implement export functionality for visualizations
6. Testing approach: Test chart rendering with various data scenarios, verify tooltip content, and test responsiveness across screen sizes

## 6. Implement Dual-Currency Display Integration [done]
### Dependencies: 16.1, 16.2, 16.4
### Description: Modify all relevant application modules to display values in both origin and destination currencies based on current exchange rates or overrides.
### Details:
Implementation details:
1. Create a dual-currency display component that can be reused across the application
2. Modify existing budget display components to incorporate the dual-currency view
3. Add configuration options for users to select which currencies to display
4. Implement visual indicators showing which values are affected by overrides or simulations
5. Ensure consistent formatting and alignment of dual-currency values
6. Testing approach: Create integration tests verifying dual-currency display across different application modules, test with various override and simulation scenarios



## TASK 017

# Task ID: 17
# Title: Develop Dashboard Summary View
# Status: done
# Dependencies: 8, 9, 10, 11, 12, 13, 14, 15, 16
# Priority: high
# Description: Create the comprehensive dashboard summary with key financial metrics.
# Details:
Implement summary cards showing total monthly and annual income & expenses. Calculate and display disposable income projection. Show required gross income to meet lifestyle target. Calculate and display the felt cost of private school (factoring in tax savings from NHR). Create rent vs. buy comparison visualization. Add scenario save and clone functionality.

# Test Strategy:
Verify all summary calculations against manual calculations. Test that all data from other modules is correctly reflected in the summary. Ensure visualizations accurately represent the data.

# Subtasks:
## 1. Create Dashboard Layout and Summary Cards Structure [done]
### Dependencies: None
### Description: Implement the basic dashboard layout with placeholders for all summary components and create the structure for summary cards showing monthly and annual income/expenses.
### Details:
1. Design a responsive grid layout for the dashboard with appropriate spacing and sections
2. Create reusable card components with title, value, and optional comparison indicators
3. Implement placeholder cards for total monthly income, monthly expenses, annual income, and annual expenses
4. Add styling for positive/negative values with appropriate color coding
5. Ensure mobile responsiveness with appropriate breakpoints
6. Test the layout across different screen sizes and ensure all placeholders render correctly

## 2. Implement Income and Expense Summary Calculations [done]
### Dependencies: 17.1
### Description: Connect the summary cards to actual data and implement the calculations for total monthly and annual income and expenses.
### Details:
1. Create data aggregation functions to sum all income sources by month and year
2. Implement expense aggregation functions to total all expenses by month and year
3. Connect the summary cards created in subtask 1 to these calculation functions
4. Add number formatting with appropriate currency symbols and decimal places
5. Implement comparison with previous period (month/year) if historical data is available
6. Test with various income and expense scenarios to verify calculations
7. Add loading states for when calculations are in progress

## 3. Develop Disposable Income Projection Component [done]
### Dependencies: 17.2
### Description: Calculate and display disposable income projections based on current income and expense data.
### Details:
1. Create a projection algorithm that calculates disposable income (income minus expenses) over time
2. Implement a visualization component (chart or graph) to display the projection
3. Add toggles for monthly vs. annual view
4. Include a summary card showing current disposable income and projected change
5. Add tooltip explanations for the projection methodology
6. Implement color coding to indicate positive/negative trends
7. Test with various income/expense scenarios to verify projection accuracy
8. Ensure the component updates when underlying data changes

## 4. Implement Required Gross Income Calculator [done]
### Dependencies: 17.2
### Description: Create a component that calculates and displays the required gross income to meet the user's lifestyle target.
### Details:
1. Design an input interface for users to set their lifestyle target
2. Implement the calculation logic that factors in taxes and expenses to determine required gross income
3. Create a visual indicator showing the gap between current and required income
4. Add explanatory text about how the calculation works
5. Implement sensitivity analysis to show how changes in expenses affect required income
6. Test with various tax scenarios and lifestyle targets
7. Add the ability to save target lifestyle goals

## 5. Develop Private School Cost Analysis Component [done]
### Dependencies: 17.2
### Description: Calculate and display the felt cost of private school, factoring in tax savings from NHR (Non-Habitual Resident) status.
### Details:
1. Create input fields for private school tuition costs
2. Implement calculation logic for tax savings under NHR status
3. Calculate the net 'felt cost' after tax considerations
4. Create a comparative visualization showing costs with and without NHR benefits
5. Add explanatory tooltips about the NHR program and how it affects education costs
6. Include a summary card showing the annual savings from NHR status
7. Test with various tuition costs and tax scenarios
8. Ensure all calculations update when tax parameters change

## 6. Create Rent vs. Buy Comparison Visualization [done]
### Dependencies: 17.2
### Description: Implement an interactive visualization comparing the financial implications of renting versus buying property.
### Details:
1. Design a side-by-side comparison layout for rent vs. buy scenarios
2. Implement calculation logic for total cost of ownership for buying (mortgage, taxes, maintenance, appreciation)
3. Create calculation logic for total rental costs over time
4. Develop an interactive chart showing the crossover point where buying becomes more economical than renting
5. Add sliders for key variables (interest rates, property appreciation, rent increases)
6. Include a summary of key metrics (break-even time, 5-year cost difference, etc.)
7. Test with various property values, rental rates, and timeframes
8. Ensure all visualizations update dynamically when inputs change

## 7. Implement Scenario Management Functionality [done]
### Dependencies: 17.3, 17.4, 17.5, 17.6
### Description: Add the ability to save, clone, and manage different financial scenarios within the dashboard.
### Details:
1. Design a scenario management UI with save, clone, and delete options
2. Implement data structure for storing complete scenario configurations
3. Create save functionality that captures all current dashboard settings and calculations
4. Implement clone functionality to duplicate scenarios for comparison
5. Add a scenario selector dropdown or tabs in the dashboard header
6. Create a comparison view to see multiple scenarios side by side
7. Implement local storage or database persistence for saved scenarios
8. Test scenario switching to ensure all dashboard components update correctly
9. Add export/import functionality for scenarios



## TASK 018

# Task ID: 18
# Title: Implement Portugal NHR Tax Logic
# Status: done
# Dependencies: 7, 8
# Priority: high
# Description: Create the tax calculation logic specific to Portugal's Non-Habitual Resident program.
# Details:
Implement simplified tax calculation for Portugal's NHR regime. Include logic for different income types (employment, passive, etc.). Create functions to calculate net income from gross based on the tax regime. Add explanatory tooltips about tax assumptions.

# Test Strategy:
Test tax calculations against known examples. Verify that different income types are taxed correctly under NHR rules. Test edge cases and boundary conditions.

# Subtasks:
## 1. Create Portugal NHR Tax Rate Constants and Configuration [done]
### Dependencies: None
### Description: Define all tax rate constants, thresholds, and configuration parameters needed for Portugal's NHR tax calculations.
### Details:
Implementation details:
1. Create a new file `portugal_nhr_tax_config.js` to store all tax constants
2. Define tax rates for different income types (employment income at 20%, passive income at 10%, etc.)
3. Define income thresholds and brackets if applicable
4. Include social security contribution rates
5. Add configuration for different income categories (employment, self-employment, capital gains, dividends, rental, etc.)
6. Document each constant with comments explaining its purpose and source
7. Testing approach: Create unit tests to verify constants match official Portugal NHR tax documentation

## 2. Implement Core NHR Tax Calculation Functions [done]
### Dependencies: 18.1
### Description: Create the core calculation functions that will handle the basic tax computations for different income types under the NHR regime.
### Details:
Implementation details:
1. Create a new file `portugal_nhr_calculator.js`
2. Implement function `calculateEmploymentTax(grossIncome)` for employment income
3. Implement function `calculatePassiveIncomeTax(grossIncome, incomeType)` for passive income types
4. Implement function `calculateSocialSecurityContributions(grossIncome, incomeType)` 
5. Create helper functions for any special deductions or exemptions
6. Ensure all functions properly use the constants defined in subtask 1
7. Testing approach: Write unit tests with various income scenarios to verify calculations match expected outcomes based on Portugal's tax laws

## 3. Develop Income Type Classification System [done]
### Dependencies: 18.1, 18.2
### Description: Create a system to classify different income streams according to Portugal's NHR tax categories and apply the appropriate tax calculation.
### Details:
Implementation details:
1. Create an income classifier function that categorizes income based on source and type
2. Implement logic to determine if income qualifies for NHR benefits
3. Create mapping between application's income categories and Portugal's tax categories
4. Implement function `classifyIncomeForNHR(incomeSource, incomeAmount, additionalDetails)`
5. Add validation to ensure income classification meets NHR requirements
6. Create a router function that directs income to the appropriate tax calculation function
7. Testing approach: Test with various income scenarios to ensure proper classification and routing to correct tax functions

## 4. Implement Comprehensive Gross-to-Net Calculator [done]
### Dependencies: 18.2, 18.3
### Description: Create a unified calculator that processes multiple income streams, applies appropriate NHR tax rules, and calculates total net income.
### Details:
Implementation details:
1. Create main function `calculatePortugalNHRTax(incomeStreams)` that accepts an array of income objects
2. For each income stream, classify and calculate applicable tax using functions from subtasks 2 and 3
3. Implement aggregation logic to combine tax results across different income types
4. Calculate total tax liability and net income
5. Return detailed breakdown of calculations for each income stream and totals
6. Handle edge cases like income caps, minimum tax thresholds, etc.
7. Testing approach: Create integration tests with complex income scenarios combining multiple income types

## 5. Integrate NHR Calculator with Application Data Flow [done]
### Dependencies: 18.4
### Description: Connect the Portugal NHR tax calculator with the application's existing data structures and user flow.
### Details:
Implementation details:
1. Modify application's main tax calculation pipeline to include Portugal NHR option
2. Create adapter functions to convert application data format to format required by NHR calculator
3. Implement country detection logic to apply NHR calculations only when Portugal is selected
4. Add user option to toggle between standard Portugal tax calculation and NHR regime
5. Ensure calculator properly handles currency conversions if needed
6. Update any dependent visualizations or reports to display NHR-specific information
7. Testing approach: Create end-to-end tests that verify the entire flow from user input to displayed results

## 6. Add User-Facing Explanations and Documentation [done]
### Dependencies: 18.5
### Description: Implement tooltips, explanations, and documentation to help users understand the Portugal NHR tax calculations.
### Details:
Implementation details:
1. Create tooltip content explaining NHR eligibility requirements
2. Add explanatory text for each income type and how it's taxed under NHR
3. Implement tooltips that appear when hovering over tax calculation results
4. Create a detailed breakdown view that explains each step of the calculation
5. Add disclaimers about tax assumptions and recommendation to consult a tax professional
6. Include references to relevant Portuguese tax legislation
7. Testing approach: Conduct user testing to ensure explanations are clear and helpful; verify all tooltips display correctly across devices



## TASK 019

# Task ID: 19
# Title: Create User Flow Navigation
# Status: done
# Dependencies: 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17
# Priority: high
# Description: Implement the step-by-step navigation flow as outlined in the PRD.
# Details:
Create a multi-step form navigation with progress indicator. Implement next/previous buttons between sections. Add validation to ensure required fields are completed before proceeding. Create a sidebar or top navigation for quick jumping between sections.

# Test Strategy:
Test the complete user flow from start to finish. Verify that validation works correctly and prevents proceeding with invalid data. Test navigation between non-sequential sections.

# Subtasks:
## 1. Create Multi-Step Form Structure and State Management [done]
### Dependencies: None
### Description: Set up the basic structure for the multi-step form and implement the state management to track form data across steps.
### Details:
Implementation details:
1. Create a parent component to house the multi-step form
2. Define the data model for all form fields across all steps
3. Set up state management (using Context API, Redux, or local state with prop drilling)
4. Create a mechanism to persist form state between steps
5. Implement functions to handle form data changes
6. Add state for tracking current active step

Testing approach:
- Verify state updates correctly when form fields change
- Confirm state persists when navigating between steps
- Test that the form data model captures all required fields

<info added on 2025-04-17T21:29:27.060Z>
For the multi-step form structure and state management, I recommend adding:

```jsx
// Recommended component structure
src/
  components/
    forms/
      FormContainer.tsx       // Parent container managing state and navigation
      StepIndicator.tsx       // Visual indicator showing progress through steps
      steps/                  // Individual form step components
        UserProfileForm.tsx
        IncomeForm.tsx
        HousingForm.tsx
        // ... other step components

// FormContainer.tsx state example
const [formData, setFormData] = useState({
  userProfile: { name: '', age: '', occupation: '' },
  income: { salary: 0, additionalIncome: 0 },
  housing: { rent: 0, utilities: 0 },
  // ... other sections
});

// Navigation functions
const goToNextStep = () => {
  if (validateCurrentStep()) {
    setCurrentStep(prev => Math.min(prev + 1, TOTAL_STEPS - 1));
  }
};

const goToPreviousStep = () => {
  setCurrentStep(prev => Math.max(prev - 1, 0));
};
```

Consider implementing form persistence with:
1. localStorage/sessionStorage for page refreshes
2. Custom hook like `useFormState` to centralize state logic
3. Form validation per step before allowing progression

For optimal UX, add URL-based navigation using query parameters to allow direct access to specific steps and browser back/forward navigation support.
</info added on 2025-04-17T21:29:27.060Z>

## 2. Implement Step Navigation Controls [done]
### Dependencies: 19.1
### Description: Create the next/previous navigation buttons and the logic to move between form steps.
### Details:
Implementation details:
1. Create reusable Next and Previous button components
2. Implement navigation logic to move forward and backward between steps
3. Add conditional rendering to show/hide buttons based on current step (e.g., no Previous on first step)
4. Create event handlers for the navigation buttons
5. Ensure form state is preserved during navigation
6. Add transition animations between steps for better UX

Testing approach:
- Verify navigation works correctly in both directions
- Test edge cases (first step, last step)
- Confirm animations work smoothly
- Ensure state is maintained when navigating

## 3. Build Progress Indicator Component [done]
### Dependencies: 19.1
### Description: Create a visual progress indicator that shows users their current position in the multi-step form.
### Details:
Implementation details:
1. Design and implement a progress bar or stepper component
2. Connect the progress indicator to the current step state
3. Style the indicator to show completed, current, and upcoming steps
4. Add labels for each step in the progress indicator
5. Ensure the indicator updates correctly when steps change
6. Make the progress indicator responsive for different screen sizes

Testing approach:
- Verify the indicator correctly reflects the current step
- Test responsive behavior on different screen sizes
- Ensure accessibility requirements are met
- Check that visual states (completed, current, upcoming) render correctly

## 4. Implement Form Validation System [done]
### Dependencies: 19.1, 19.2
### Description: Create a validation system to ensure required fields are completed before allowing users to proceed to the next step.
### Details:
Implementation details:
1. Define validation rules for each form field
2. Implement validation functions for different field types
3. Create error message display components
4. Add validation checks when users attempt to proceed to next step
5. Implement real-time validation feedback as users type
6. Add visual indicators for invalid fields
7. Ensure Next button is disabled until required fields are valid

Testing approach:
- Test validation with valid and invalid inputs
- Verify error messages display correctly
- Confirm Next button behavior based on validation state
- Test real-time validation feedback

## 5. Create Quick Navigation Sidebar/Topbar [done]
### Dependencies: 19.1, 19.3, 19.4
### Description: Implement a sidebar or top navigation component that allows users to quickly jump between form sections.
### Details:
Implementation details:
1. Design and implement a sidebar or top navigation component
2. Create navigation links for each form step
3. Connect navigation to the step state management
4. Add validation checks before allowing navigation to ensure data integrity
5. Style the navigation to indicate completed, current, and locked steps
6. Implement responsive design for the navigation component
7. Add tooltips to explain navigation restrictions when steps are locked

Testing approach:
- Verify navigation correctly jumps to selected steps
- Test validation prevents navigation to future steps when required fields are incomplete
- Confirm visual indicators for step states work correctly
- Test responsive behavior on different screen sizes

## 6. Implement Responsive Design and Final Integration [done]
### Dependencies: 19.1, 19.2, 19.3, 19.4, 19.5
### Description: Ensure the entire multi-step form navigation system is responsive and integrate all components into a cohesive user experience.
### Details:
Implementation details:
1. Apply responsive design principles to all form components
2. Implement media queries for different screen sizes
3. Create mobile-specific navigation patterns when needed
4. Ensure consistent styling across all components
5. Optimize transitions and animations for performance
6. Perform final integration of all components
7. Add keyboard navigation support for accessibility
8. Implement focus management between steps

Testing approach:
- Test the complete form flow on various devices and screen sizes
- Verify all components work together seamlessly
- Conduct accessibility testing (keyboard navigation, screen readers)
- Perform end-to-end testing of the complete user flow
- Test edge cases like browser refresh and back button behavior



## TASK 020

# Task ID: 20
# Title: Implement Scenario Save Functionality
# Status: done
# Dependencies: 4, 17
# Priority: medium
# Description: Create functionality to save and load budget scenarios.
# Details:
Implement local storage saving of complete scenarios. Create UI for naming and managing saved scenarios. Add export functionality to JSON format. For MVP, focus on client-side storage rather than server persistence.

# Test Strategy:
Test saving and loading scenarios from local storage. Verify that all data is correctly preserved when loading a saved scenario. Test edge cases like loading with incompatible schema versions.

# Subtasks:
## 1. Implement State Serialization and Local Storage Integration [done]
### Dependencies: None
### Description: Create functionality to serialize the budget scenario state and save it to browser's local storage
### Details:
Implementation steps:
1. Define a data structure for serialized scenarios that includes all necessary budget data, scenario name, and timestamp
2. Create a ScenarioStorage service with methods for:
   - serializeCurrentState(): Convert current application state to storable format
   - saveToLocalStorage(scenarioName): Save serialized state with a name
   - listSavedScenarios(): Return metadata about all saved scenarios
   - loadFromLocalStorage(scenarioId): Retrieve a saved scenario
   - deleteFromLocalStorage(scenarioId): Remove a saved scenario
3. Implement error handling for storage limits and invalid data
4. Add unit tests for serialization/deserialization logic
5. Test with various budget scenarios to ensure all data is properly preserved

Testing approach:
- Write unit tests for the serialization/deserialization logic
- Test storage and retrieval of scenarios with different complexity levels
- Verify proper error handling when storage limits are reached

## 2. Create UI for Scenario Management [done]
### Dependencies: 20.1
### Description: Develop user interface components for saving, loading, and managing budget scenarios
### Details:
Implementation steps:
1. Create a ScenarioManager modal component with tabs for:
   - Save Current Scenario (with name input field)
   - Load Saved Scenario (with list of saved scenarios)
   - Manage Scenarios (rename, delete options)
2. Implement a ScenarioList component to display saved scenarios with:
   - Scenario name
   - Creation/modification date
   - Action buttons (load, rename, delete)
3. Add confirmation dialogs for overwriting and deletion actions
4. Create success/error notification components for feedback
5. Connect UI components to the ScenarioStorage service from subtask 1
6. Add keyboard shortcuts for common operations (Ctrl+S for save, etc.)

Testing approach:
- Test UI rendering with various screen sizes
- Verify all user interactions work as expected
- Test edge cases like attempting to save without a name
- Ensure proper feedback is shown for all operations

## 3. Implement JSON Export and Import Functionality [done]
### Dependencies: 20.1, 20.2
### Description: Add capability to export scenarios to JSON files and import them back into the application
### Details:
Implementation steps:
1. Extend the ScenarioStorage service with:
   - exportToJson(scenarioId): Generate downloadable JSON file
   - importFromJson(file): Parse uploaded JSON and validate structure
2. Add export/import buttons to the ScenarioManager UI
3. Create a file upload component for importing scenarios
4. Implement validation for imported files to ensure they match expected format
5. Add version information to exported files for future compatibility
6. Handle potential conflicts when importing (e.g., same scenario name exists)
7. Provide detailed error messages for invalid imports

Testing approach:
- Test export functionality with various scenario complexities
- Test importing valid and invalid JSON files
- Verify round-trip functionality (export then import)
- Test handling of malformed JSON files
- Ensure proper error messages are displayed for invalid imports



## TASK 021

# Task ID: 21
# Title: Develop Responsive Design
# Status: done
# Dependencies: 2, 19
# Priority: medium
# Description: Ensure the application is fully responsive across desktop, tablet, and mobile devices.
# Details:
Implement responsive layouts using Tailwind's responsive utilities. Create mobile-specific component variants where needed. Test and optimize for touch interfaces. Ensure all forms and inputs are usable on smaller screens.

# Test Strategy:
Test the application on various device sizes and orientations. Verify that all functionality works correctly on mobile devices. Check for any UI/UX issues specific to touch interfaces.

# Subtasks:
## 1. Set up responsive breakpoints and base layout structure [done]
### Dependencies: None
### Description: Configure Tailwind's responsive breakpoints and establish the base responsive layout structure for the application
### Details:
1. Review and customize Tailwind's default breakpoints in tailwind.config.js to match project requirements (sm, md, lg, xl, 2xl)
2. Create a responsive container component that will serve as the base layout wrapper
3. Implement a responsive navigation system that transforms into a mobile menu on smaller screens
4. Set up responsive grid layouts for main content areas using Tailwind's grid utilities
5. Test the base layout structure across different viewport sizes
6. Document the responsive strategy and breakpoint standards for the team

## 2. Implement responsive typography and spacing system [done]
### Dependencies: 21.1
### Description: Create a consistent responsive typography and spacing system that scales appropriately across device sizes
### Details:
1. Define a responsive typography scale using Tailwind's text utilities with different sizes at different breakpoints
2. Create utility classes for responsive margins and padding that adjust based on screen size
3. Implement responsive font sizes for headings, body text, and UI elements
4. Ensure proper line heights and letter spacing for readability on all devices
5. Test text overflow and wrapping behavior on small screens
6. Create a documentation page showing the typography system across breakpoints

## 3. Develop mobile-specific component variants [done]
### Dependencies: 21.1, 21.2
### Description: Create and implement mobile-specific variants for complex components that require different layouts or interactions on smaller screens
### Details:
1. Identify components that need mobile-specific variants (data tables, complex forms, charts, etc.)
2. Create simplified mobile versions of data tables that stack or reformat content
3. Implement collapsible sections for complex forms on mobile
4. Develop touch-friendly alternatives for hover-dependent components
5. Create mobile-specific navigation patterns (bottom tabs, etc.)
6. Test each component variant on actual mobile devices
7. Document when and how to use each component variant

## 4. Optimize forms and inputs for touch interfaces [done]
### Dependencies: 21.3
### Description: Ensure all forms and input elements are usable and accessible on touch devices with appropriate sizing and spacing
### Details:
1. Increase touch target sizes for all interactive elements (minimum 44x44px)
2. Add appropriate spacing between touch targets to prevent accidental taps
3. Implement mobile-optimized form layouts with full-width inputs
4. Create touch-friendly custom form controls (dropdowns, date pickers, etc.)
5. Ensure form validation messages are clearly visible on small screens
6. Test form completion on various mobile devices and browsers
7. Implement mobile-specific keyboard types for different input fields

## 5. Conduct comprehensive responsive testing and optimization [done]
### Dependencies: 21.1, 21.2, 21.3, 21.4
### Description: Perform thorough testing across devices and browsers, and optimize performance for mobile users
### Details:
1. Create a testing matrix covering key device/browser combinations
2. Test the application on actual physical devices (not just browser emulation)
3. Identify and fix layout issues, touch target problems, and visual inconsistencies
4. Optimize image loading with responsive images (srcset, sizes attributes)
5. Implement performance optimizations for mobile users (reduced animations, etc.)
6. Test and optimize load times on slower mobile connections
7. Document any device-specific workarounds or considerations
8. Create a responsive design QA checklist for future features



## TASK 022

# Task ID: 22
# Title: Implement Form Validation
# Status: done
# Dependencies: 8, 9, 10, 11, 12, 13, 14, 15
# Priority: medium
# Description: Add comprehensive validation to all input forms.
# Details:
Implement client-side validation for all numeric inputs. Add format validation for currency and percentage inputs. Create helpful error messages for invalid inputs. Implement real-time validation feedback.

# Test Strategy:
Test validation with valid and invalid inputs. Verify that appropriate error messages are displayed. Test form submission with invalid data to ensure it's prevented.

# Subtasks:
## 1. Create Validation Utility Functions [done]
### Dependencies: None
### Description: Develop a set of reusable validation utility functions for different input types
### Details:
Implement a validation utility module with functions for: 1) Numeric validation (integers, decimals, ranges), 2) Currency format validation (proper currency symbols, decimal places), 3) Percentage validation (0-100% range, decimal precision), 4) Common input validation (required fields, min/max length). Each function should return a boolean result and an appropriate error message. Test each function with various valid and invalid inputs to ensure accuracy. These utilities will serve as the foundation for all form validation throughout the application.

## 2. Implement Form Input Component with Validation [done]
### Dependencies: 22.1
### Description: Create or enhance form input components that incorporate validation capabilities
### Details:
Modify existing input components or create new ones that: 1) Accept validation rules as props, 2) Use the validation utility functions from subtask 1, 3) Track input validity state, 4) Support different input types (text, number, currency, percentage), 5) Include proper ARIA attributes for accessibility. Implement internal state management to track validation status. Test components individually with various validation rules to ensure they correctly validate inputs and maintain proper state.

## 3. Develop Real-time Validation Feedback UI [done]
### Dependencies: 22.2
### Description: Create visual feedback mechanisms for real-time validation results
### Details:
Implement UI elements and styles for validation feedback: 1) Error message display component with appropriate styling, 2) Visual indicators for valid/invalid inputs (border colors, icons), 3) Tooltip or inline help text for validation requirements, 4) Animation for transitions between states. Connect these UI elements to the validation state from subtask 2. Ensure feedback is accessible and follows design system guidelines. Test with screen readers and keyboard navigation to verify accessibility compliance.

## 4. Integrate Form-Level Validation Logic [done]
### Dependencies: 22.2, 22.3
### Description: Implement form-level validation that coordinates validation across multiple inputs
### Details:
Create a form validation manager that: 1) Tracks validation state of all inputs within a form, 2) Provides form-level validation methods (validateAll, resetAll), 3) Prevents submission of invalid forms, 4) Handles interdependent field validation (where one field's validity depends on another), 5) Manages focus movement to invalid fields. Implement this as a higher-order component or context provider. Test with complex forms containing multiple interdependent fields to ensure proper validation coordination.

## 5. Apply Validation to All Application Forms [done]
### Dependencies: 22.1, 22.2, 22.3, 22.4
### Description: Systematically implement validation across all forms in the application
### Details:
For each form in the application: 1) Identify all inputs requiring validation, 2) Define appropriate validation rules using the utility functions, 3) Apply the enhanced input components with validation, 4) Implement form-level validation using the form validation manager, 5) Test each form with valid and invalid inputs, 6) Verify error messages are clear and helpful, 7) Ensure real-time feedback works correctly. Create a validation test plan document to track progress across all forms. Conduct user testing to verify validation messages are understandable and helpful.



## TASK 023

# Task ID: 23
# Title: Create Help Text and Tooltips
# Status: pending
# Dependencies: 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
# Priority: low
# Description: Add contextual help text and tooltips throughout the application.
# Details:
Add information icons with tooltips explaining concepts and calculations. Create help text for complex inputs. Add explanations of tax implications and financial concepts. Ensure help text is clear and concise.

# Test Strategy:
Review all help text for clarity and accuracy. Test tooltip functionality across different browsers and devices.


## TASK 024

# Task ID: 24
# Title: Implement Error Handling
# Status: done
# Dependencies: 3, 19
# Priority: medium
# Description: Add comprehensive error handling throughout the application.
# Details:
Implement error boundaries to catch and display React errors. Add error handling for API calls with appropriate user feedback. Create fallback UI for when components fail. Implement logging for debugging purposes.

# Test Strategy:
Test error scenarios by forcing API failures and component errors. Verify that appropriate error messages are displayed to users. Check that the application can recover from errors.

# Subtasks:
## 1. Create React Error Boundary Component [done]
### Dependencies: None
### Description: Implement a reusable Error Boundary component to catch and handle React rendering errors
### Details:
Create an ErrorBoundary class component that uses componentDidCatch and getDerivedStateFromError lifecycle methods. The component should: 1) Capture errors in child component trees, 2) Display a fallback UI when errors occur, 3) Log error information for debugging. Include props for custom fallback UI and error reporting callbacks. Test by creating components that intentionally throw errors to verify the boundary catches them correctly.

## 2. Implement API Error Handling Utilities [done]
### Dependencies: None
### Description: Create utility functions to standardize API error handling across the application
### Details:
Develop a set of utility functions for API error handling: 1) Create a wrapper for fetch/axios that includes error handling, 2) Implement functions to parse different error types (network errors, 4xx, 5xx responses), 3) Add timeout handling for API calls, 4) Create utility to retry failed requests with exponential backoff. Test these utilities with mocked API responses that simulate various error conditions.

## 3. Build Fallback UI Component Library [done]
### Dependencies: 24.1
### Description: Create a set of reusable fallback UI components for different error scenarios
### Details:
Develop a library of fallback UI components: 1) Generic error display component, 2) Empty state component for when data is missing, 3) Loading state component for pending operations, 4) Offline indicator for network issues, 5) Retry button component. Each component should be customizable with props for different messages and actions. Ensure components follow the application's design system. Test each component in isolation with various props configurations.

## 4. Implement Error Logging System [done]
### Dependencies: 24.1, 24.2
### Description: Create a centralized error logging system to capture and report errors
### Details:
Implement a logging system that: 1) Captures errors from React components and API calls, 2) Records error details, stack traces, and context information, 3) Supports different log levels (warning, error, critical), 4) Provides option to send logs to a backend service or external monitoring tool, 5) Includes user and session information when available. Test by triggering various error scenarios and verifying logs are captured correctly with appropriate metadata.

## 5. Create User Feedback Mechanisms [done]
### Dependencies: 24.2, 24.3
### Description: Implement components and services to provide meaningful error feedback to users
### Details:
Develop user feedback mechanisms: 1) Create a toast notification system for transient errors, 2) Implement modal dialogs for critical errors requiring user action, 3) Add inline error messages for form validation errors, 4) Create a global error state manager (using Context API or Redux), 5) Implement error message templates with user-friendly language. Test each feedback mechanism with different error scenarios and verify they display appropriate information to users.

## 6. Integrate and Test Error Handling System [done]
### Dependencies: 24.1, 24.2, 24.3, 24.4, 24.5
### Description: Apply the error handling components throughout the application and create comprehensive tests
### Details:
Integrate all error handling components: 1) Wrap key application sections with Error Boundaries, 2) Update all API calls to use the error handling utilities, 3) Replace existing error handling with the new system, 4) Create an error testing page that demonstrates all error scenarios, 5) Write integration tests that verify the complete error handling flow, 6) Create documentation for the error handling system. Test by simulating various error conditions and verifying the application gracefully handles them with appropriate user feedback.



## TASK 025

# Task ID: 25
# Title: Optimize Performance
# Status: pending
# Dependencies: 17, 19
# Priority: low
# Description: Optimize application performance for smooth user experience.
# Details:
Implement memoization for expensive calculations. Optimize component rendering with React.memo and useMemo. Add loading states for async operations. Implement virtualization for long lists if needed.

# Test Strategy:
Measure and compare performance before and after optimizations. Test with large datasets to ensure the application remains responsive. Use React DevTools to identify and address performance bottlenecks.

# Subtasks:
## 1. Implement Performance Profiling and Benchmarking [pending]
### Dependencies: None
### Description: Set up performance profiling tools and establish baseline metrics to identify bottlenecks in the application
### Details:
1. Install React DevTools and Chrome Performance tab for profiling
2. Create a performance testing script that measures key metrics (FPS, load time, time to interactive)
3. Identify the top 5 performance bottlenecks in the application
4. Document baseline metrics for each page/component
5. Set up Lighthouse CI or similar tool for automated performance testing
6. Test on both high-end and low-end devices to establish comprehensive baselines
7. Create a performance budget based on findings

## 2. Implement Memoization for Expensive Calculations [pending]
### Dependencies: 25.1
### Description: Apply memoization techniques to prevent redundant calculations and improve performance
### Details:
1. Identify expensive calculations in the codebase using the profiling data from subtask 1
2. Implement useMemo for complex derived state calculations
3. Create custom memoization utilities for non-React calculations
4. Apply memoization to data transformation functions
5. Implement reselect or similar library for Redux selectors if applicable
6. Test before/after performance impact of each memoization implementation
7. Document memoization patterns used for future reference

## 3. Optimize Component Rendering [pending]
### Dependencies: 25.1
### Description: Prevent unnecessary re-renders and optimize component rendering cycles
### Details:
1. Identify components that re-render excessively using React DevTools Profiler
2. Apply React.memo to functional components that render often but with the same props
3. Implement custom comparison functions for React.memo where default shallow comparison is insufficient
4. Use useCallback for event handlers and functions passed as props
5. Restructure component tree to isolate frequently changing state
6. Fix any anti-patterns like creating new objects/arrays in render
7. Measure and document rendering performance improvements

## 4. Implement Loading States and Async Operation Optimization [pending]
### Dependencies: 25.1
### Description: Add proper loading states and optimize asynchronous operations for better user experience
### Details:
1. Implement skeleton screens for primary content areas during loading
2. Add loading indicators for user-initiated actions
3. Implement debouncing for search inputs and other frequent user interactions
4. Set up request cancellation for obsolete API calls
5. Implement data prefetching for anticipated user actions
6. Add error boundaries to prevent cascading failures
7. Implement retry logic for failed network requests
8. Test and measure perceived performance improvements

## 5. Implement Virtualization for Long Lists [pending]
### Dependencies: 25.1, 25.3
### Description: Apply virtualization techniques to efficiently render large data sets
### Details:
1. Identify lists or grids in the application that contain more than 50 items
2. Select appropriate virtualization library (react-window, react-virtualized, or similar)
3. Implement virtualized lists to replace existing inefficient list rendering
4. Add infinite scrolling or pagination where appropriate
5. Optimize item rendering within virtualized lists using memoization techniques
6. Implement data chunking for large datasets
7. Test virtualization performance on various devices and screen sizes
8. Measure and document memory usage and rendering performance improvements



## TASK 026

# Task ID: 26
# Title: Create Clone Scenario Functionality
# Status: done
# Dependencies: 20
# Priority: low
# Description: Implement the ability to clone and modify existing scenarios.
# Details:
Add a clone button to saved scenarios. Implement logic to create a copy with a new name. Allow users to modify cloned scenarios independently. Update UI to clearly indicate which scenario is being viewed/edited.

# Test Strategy:
Test cloning scenarios and verify that changes to the clone don't affect the original. Verify that all data is correctly copied when cloning.

# Subtasks:
## 1. Add Clone Button to Scenario UI [done]
### Dependencies: None
### Description: Add a clone button to the saved scenarios interface that allows users to create a copy of an existing scenario.
### Details:
Implementation details:
1. Identify the appropriate location in the UI to add the clone button (likely next to edit/delete buttons for each scenario)
2. Design and implement the button with appropriate styling that matches the existing UI
3. Add a tooltip or helper text to explain the clone functionality
4. Implement click handler that will trigger the cloning process
5. Add visual feedback (like a loading indicator) when clone is in progress
6. Test the button rendering and click event handling
7. Ensure the button is accessible and works with keyboard navigation

## 2. Implement Scenario Cloning Logic [done]
### Dependencies: 26.1
### Description: Create the core logic to duplicate an existing scenario with all its properties and assign it a new unique identifier and name.
### Details:
Implementation details:
1. Create a cloneScenario function that takes an existing scenario ID as input
2. Fetch the complete data of the source scenario from the data store
3. Create a deep copy of the scenario object to ensure no references are shared
4. Generate a new unique ID for the cloned scenario
5. Modify the name to indicate it's a copy (e.g., append 'Copy' or '(2)' to the original name)
6. Preserve all other scenario properties and settings
7. Save the new scenario to the data store
8. Implement error handling for cases where the source scenario doesn't exist or cloning fails
9. Return the new scenario ID upon successful cloning
10. Write unit tests to verify the cloning logic works correctly with various scenario configurations

## 3. Implement UI Feedback and Navigation After Cloning [done]
### Dependencies: 26.1, 26.2
### Description: Update the UI to provide feedback after cloning and navigate the user to the newly created scenario for editing.
### Details:
Implementation details:
1. Create a success notification that appears after successful cloning
2. Implement automatic navigation to the edit view of the newly created scenario
3. Highlight or otherwise indicate the newly created scenario in the scenarios list
4. Add visual indicators to clearly show which scenario is currently being viewed/edited
5. Update the page title or breadcrumb navigation to reflect the current scenario name
6. Ensure the browser history is properly updated so the back button works as expected
7. Add a visual indicator or badge to recently cloned scenarios in the list view
8. Test the navigation flow and UI feedback with different user interaction patterns
9. Ensure all UI states properly reflect the current scenario being edited

## 4. Implement Independent Modification of Cloned Scenarios [done]
### Dependencies: 26.2, 26.3
### Description: Ensure that modifications to cloned scenarios don't affect the original and update the data model to track relationships between original and cloned scenarios if needed.
### Details:
Implementation details:
1. Verify that the deep copy implementation in the cloning logic properly separates all nested objects and arrays
2. Add unit and integration tests that modify both original and cloned scenarios to ensure changes don't affect each other
3. Consider adding a reference to the source scenario ID in the cloned scenario metadata (if tracking lineage is desired)
4. Update the scenario listing to optionally show relationships between scenarios (e.g., 'Cloned from X')
5. Implement safeguards to prevent circular cloning issues if a scenario has been cloned multiple times
6. Add database indexes or optimizations if needed to support efficient querying of related scenarios
7. Test edge cases like cloning a scenario that was itself a clone
8. Ensure the UI properly handles long chains of cloned scenarios
9. Document the cloning behavior and data model changes for other developers



## TASK 027

# Task ID: 27
# Title: Implement Vercel Deployment
# Status: pending
# Dependencies: 1, 24
# Priority: low
# Description: Set up deployment to Vercel as specified in the PRD.
# Details:
Configure Vercel project settings. Set up environment variables for API keys. Configure build settings and deployment branches. Set up preview deployments for pull requests.

# Test Strategy:
Verify successful deployment to Vercel. Test that the deployed application functions correctly. Check that environment variables are properly configured.


## TASK 028

# Task ID: 28
# Title: Add Print and Export Functionality
# Status: pending
# Dependencies: 17, 31
# Priority: low
# Description: Implement functionality to print or export budget summaries.
# Details:
Create a print-friendly view of the budget summary. Implement export to PDF functionality. Add option to export data to CSV format. Ensure exported documents are well-formatted and include all relevant information.

# Test Strategy:
Test printing from different browsers. Verify that PDF exports contain all necessary information and are properly formatted. Test CSV exports for data integrity.

# Subtasks:
## 1. Create Print-Friendly View of Budget Summary [done]
### Dependencies: None
### Description: Implement a print-friendly view of the budget summary that formats data appropriately for printing.
### Details:
Implementation steps:
1. Create a dedicated CSS file for print styles (print.css) using @media print queries
2. Design a clean, minimal layout that removes navigation, buttons, and other UI elements not needed for printing
3. Ensure all budget data is properly displayed with appropriate spacing and page breaks
4. Add a 'Print' button in the UI that triggers window.print() function
5. Include header with application name, date of printing, and user information
6. Format tables and charts to be clearly readable in black and white
7. Test the print functionality across different browsers (Chrome, Firefox, Safari)
8. Add print preview capability if possible

Testing approach:
- Manually test print preview in different browsers
- Verify all budget data appears correctly in printed output
- Check that page breaks occur at logical points
- Ensure printed document has appropriate headers/footers

## 2. Implement PDF Export Functionality [done]
### Dependencies: 28.1
### Description: Add the ability to export budget summaries as well-formatted PDF documents.
### Details:
Implementation steps:
1. Research and select an appropriate PDF generation library (e.g., jsPDF, html2pdf.js, or pdfmake)
2. Create a PDF template that matches the print-friendly view styling
3. Implement a function to gather all relevant budget data and format it for PDF export
4. Add an 'Export to PDF' button in the UI that triggers the PDF generation
5. Ensure the PDF includes proper formatting, tables, and potentially charts/graphs
6. Add metadata to the PDF (title, creation date, author)
7. Implement progress indicator for PDF generation
8. Allow user to specify filename for the exported PDF
9. Handle potential errors during PDF generation

Testing approach:
- Test PDF generation with various budget sizes (small, medium, large datasets)
- Verify all data is correctly represented in the PDF
- Check PDF formatting on different PDF readers
- Test performance with large datasets
- Ensure error handling works properly

## 3. Implement CSV Export Functionality [in-progress]
### Dependencies: 28.1
### Description: Add the ability to export budget data in CSV format for use in spreadsheet applications.
### Details:
Implementation steps:
1. Create a function to convert budget data into CSV format
2. Determine which fields should be included in the CSV export
3. Implement proper escaping for special characters in CSV data
4. Add an 'Export to CSV' button in the UI
5. Use the Blob API and createObjectURL to generate downloadable CSV files
6. Allow user to specify filename for the exported CSV
7. Add appropriate headers to CSV columns
8. Consider implementing options for what data to include (e.g., summary only, detailed transactions, etc.)
9. Handle potential encoding issues

Testing approach:
- Test CSV generation with various data types and special characters
- Verify CSV can be properly imported into Excel, Google Sheets, and other spreadsheet applications
- Check that all data is correctly formatted and aligned in columns
- Test with different locales to ensure proper handling of decimal separators
- Verify large datasets can be exported without performance issues



## TASK 029

# Task ID: 29
# Title: Create User Documentation
# Status: pending
# Dependencies: 19, 23
# Priority: low
# Description: Develop comprehensive user documentation and help guides.
# Details:
Create a user guide explaining how to use the application. Document all features and their purposes. Include examples and use cases. Create FAQ section addressing common questions.

# Test Strategy:
Review documentation for clarity and completeness. Have test users attempt to follow the documentation to complete tasks.


## TASK 030

# Task ID: 30
# Title: Implement Analytics
# Status: pending
# Dependencies: 19, 27
# Priority: low
# Description: Add basic analytics to track usage patterns and identify improvement areas.
# Details:
Implement client-side analytics to track feature usage. Add event tracking for key user actions. Create a simple dashboard for viewing analytics data. Ensure compliance with privacy regulations.

# Test Strategy:
Verify that analytics events are correctly triggered by user actions. Test that no sensitive user data is being collected. Check that analytics don't negatively impact application performance.


## TASK 031

# Task ID: 31
# Title: Refactor: Create Dedicated Budget Summary Page
# Status: done
# Dependencies: None
# Priority: high
# Description: Create a new dedicated page for displaying budget scenario details, moving the rendering logic from BudgetSummaryDisplay.tsx to this new page and implementing scenario loading based on URL parameters.
# Details:
Create a new page component at pages/summary/[scenarioName].tsx that will serve as a dedicated view for budget scenarios. This page should:

1. Extract and refactor the rendering logic from BudgetSummaryDisplay.tsx to this new page
2. Implement a useEffect hook to load scenario data based on the URL parameter (scenarioName)
3. Fetch the specific scenario data from local storage or your data store
4. Display a loading state while data is being retrieved
5. Handle cases where the scenario doesn't exist (show appropriate error message)
6. Include navigation options to return to the main application
7. Modify the ScenarioManager component to update the 'Load' button functionality to use Next.js router to navigate to `/summary/[scenarioName]` instead of loading the scenario in the current view
8. Ensure the page is responsive and maintains all existing functionality of the budget summary display
9. Add appropriate metadata for the page (title, description)
10. Consider adding a breadcrumb navigation for better UX

# Test Strategy:
1. Unit Tests:
   - Test the new page component renders correctly with mock scenario data
   - Verify error states are handled properly when scenario doesn't exist
   - Test loading states are displayed appropriately

2. Integration Tests:
   - Verify the ScenarioManager's 'Load' button correctly navigates to the new page with the proper URL parameter
   - Test that scenario data loads correctly from storage when the page is accessed directly via URL
   - Ensure all budget calculations and displays match the original implementation

3. Manual Testing:
   - Create several test scenarios and verify they can be accessed via direct URL
   - Test browser navigation (back/forward) works correctly with the new page
   - Verify all interactive elements on the summary page function as expected
   - Test across different screen sizes to ensure responsive design
   - Verify that deep linking works (sharing a direct link to a specific scenario)
   - Test that the page gracefully handles invalid scenario names in the URL

# Subtasks:
## 1. Create dedicated scenario summary page component with URL parameter handling [done]
### Dependencies: None
### Description: Create a new page component at pages/summary/[scenarioName].tsx that extracts the scenario name from the URL and implements the basic page structure with loading states and error handling.
### Details:
Implementation steps:
1. Create the new file at pages/summary/[scenarioName].tsx
2. Set up the basic page component structure with appropriate imports
3. Use Next.js's useRouter hook to extract the scenarioName parameter from the URL
4. Implement state variables for scenario data, loading state, and error state
5. Create a useEffect hook that triggers when the scenarioName parameter changes
6. Add loading indicator display logic while data is being fetched
7. Implement error handling for cases where the scenario doesn't exist
8. Add page metadata using Next.js Head component (title, description)
9. Add basic navigation to return to the main application
10. Test the component with various URL parameters including valid and invalid scenario names
11. Ensure the page displays appropriate loading and error states

## 2. Refactor BudgetSummaryDisplay logic into the new page component [done]
### Dependencies: 31.1
### Description: Extract and refactor the rendering logic from BudgetSummaryDisplay.tsx to the new dedicated summary page, ensuring all existing functionality is maintained.
### Details:
Implementation steps:
1. Review the existing BudgetSummaryDisplay.tsx component to understand its rendering logic and state management
2. Copy relevant rendering code from BudgetSummaryDisplay.tsx to the new page component
3. Adapt the code to work with the scenario data loaded from the URL parameter
4. Implement the data fetching logic to retrieve the specific scenario from local storage or data store
5. Ensure all calculations and visualizations from the original component are preserved
6. Refactor any component-specific code to work in the page context
7. Add responsive styling to ensure the page looks good on all device sizes
8. Implement breadcrumb navigation for better UX
9. Test the page with various scenarios to ensure all budget summary functionality works correctly
10. Verify that all charts, tables, and other visual elements render correctly
11. Ensure any interactive elements (filters, toggles, etc.) continue to function as expected

## 3. Update ScenarioManager to use router navigation for scenario loading [done]
### Dependencies: 31.1, 31.2
### Description: Modify the ScenarioManager component to update the 'Load' button functionality to navigate to the new dedicated summary page instead of loading the scenario in the current view.
### Details:
Implementation steps:
1. Import the Next.js router in the ScenarioManager component
2. Locate the 'Load' button or scenario loading functionality in the ScenarioManager
3. Modify the click handler to use router.push(`/summary/${scenarioName}`) instead of loading the scenario in the current view
4. Ensure any necessary state or context is preserved during navigation
5. Update any related UI elements or tooltips to reflect the new behavior
6. Consider adding a visual indication that the action will navigate to a new page
7. Test the updated ScenarioManager to ensure navigation works correctly
8. Verify that clicking 'Load' for different scenarios correctly navigates to the appropriate URL
9. Test the back navigation from the summary page to ensure users can return to the main application
10. Check for any edge cases or error conditions in the navigation flow
11. Ensure the user experience remains intuitive with the new navigation pattern



## TASK 032

# Task ID: 32
# Title: Implement Wizard State Persistence and Navigation System
# Status: done
# Dependencies: None
# Priority: high
# Description: Develop a robust state management system for the wizard interface using WizardContext that persists user progress in localStorage and enables reliable navigation between steps.
# Details:
Create a centralized WizardContext to manage the wizard's state across all steps:

1. Implement a React Context (WizardContext.tsx) with provider that maintains the current wizard state
2. Add automatic state persistence to localStorage under the key 'wizardInProgressState'
   - Save state on every significant change
   - Load state on wizard initialization
   - Include debouncing to prevent excessive writes
3. Refactor all wizard step components to consume the WizardContext instead of managing their own state
4. Implement an explicit 'Save Scenario' functionality:
   - Create a saveNamedScenario function that stores the current state with format 'scenario-{name}'
   - Add UI elements for naming and saving scenarios
5. Create a new page at /summary/all-scenarios that lists all saved scenarios with:
   - Scenario names and creation dates
   - Options to load, rename, or delete scenarios
   - Preview of key scenario parameters
6. Fix Back button behavior:
   - Ensure browser back/forward navigation works correctly with the wizard state
   - Implement proper state restoration when navigating between steps
   - Add confirmation dialog when leaving wizard with unsaved changes

The implementation should maintain a clear separation between the in-progress wizard state and saved scenarios, allowing users to work on multiple scenarios over time.

# Test Strategy:
1. Unit Tests:
   - Test WizardContext provider functions for saving/loading state
   - Verify proper serialization/deserialization of complex state objects
   - Test debouncing functionality for localStorage writes

2. Integration Tests:
   - Verify wizard state persists correctly when navigating between steps
   - Test that browser refresh doesn't lose wizard progress
   - Confirm saved scenarios are properly stored and can be reloaded
   - Validate that the Back button correctly restores previous states

3. End-to-End Tests:
   - Complete a full wizard flow, verifying state is maintained at each step
   - Test scenario saving and loading from the all-scenarios page
   - Simulate browser close/reopen to verify state restoration
   - Test edge cases like invalid state data or storage quota exceeded

4. Manual Testing:
   - Verify UI feedback when saving/loading scenarios
   - Test navigation between multiple saved scenarios
   - Confirm proper handling of the browser's back/forward buttons
   - Validate that the confirmation dialog appears appropriately when leaving with unsaved changes

# Subtasks:
## 1. Create WizardContext with localStorage Persistence [done]
### Dependencies: None
### Description: Implement a React Context system that manages wizard state and persists it to localStorage with debouncing
### Details:
1. Create a new file `WizardContext.tsx` with a React Context and Provider
2. Define the state interface with all necessary wizard fields
3. Implement useState and useEffect hooks in the provider to manage state
4. Add localStorage persistence logic:
   - Create a loadState function that retrieves state from 'wizardInProgressState' key
   - Implement a debounced saveState function using setTimeout
   - Set up an effect hook to save state on changes
   - Add error handling for localStorage operations
5. Expose context methods:
   - updateState(newState) - for updating partial state
   - resetState() - for clearing state
   - getCurrentStep() - for getting current wizard position
   - navigateToStep(step) - for changing steps
6. Test the context by creating a simple component that uses it and verifies localStorage persistence works

## 2. Refactor Wizard Steps to Use WizardContext [done]
### Dependencies: 32.1
### Description: Update all wizard step components to consume the WizardContext instead of managing their own state
### Details:
1. Import and use the WizardContext in each wizard step component
2. Replace local state management with context methods:
   - Replace useState calls with context state values
   - Update form handlers to use context.updateState
   - Modify navigation logic to use context.navigateToStep
3. Ensure data validation still works correctly with the new state management
4. Update the main wizard container component to wrap children with WizardContextProvider
5. Fix the Back button behavior:
   - Use the browser history API to handle back/forward navigation
   - Implement an event listener for beforeunload to show confirmation when leaving with unsaved changes
   - Ensure state is properly restored when navigating between steps
6. Test the refactored components by completing a full wizard flow and verifying state persists between steps and page refreshes

## 3. Implement Named Scenario Management [done]
### Dependencies: 32.1, 32.2
### Description: Create functionality to save, load, and manage named scenarios with a dedicated summary page
### Details:
1. Extend WizardContext with scenario management functions:
   - saveNamedScenario(name) - saves current state with key 'scenario-{name}'
   - loadScenario(name) - loads a saved scenario into current state
   - deleteScenario(name) - removes a saved scenario
   - listScenarios() - returns all saved scenarios with metadata
2. Add UI components for scenario management:
   - Create a SaveScenarioDialog component with name input
   - Add save button to wizard navigation
   - Implement confirmation dialogs for overwriting/deleting
3. Create the scenarios summary page at /summary/all-scenarios:
   - Build a ScenariosList component that displays all saved scenarios
   - Include creation dates and key parameters in the list
   - Add action buttons for load, rename, and delete operations
   - Implement sorting and filtering options
4. Style the new components to match the application design
5. Test the scenario management by:
   - Creating multiple scenarios
   - Verifying they appear correctly on the summary page
   - Testing load, rename and delete operations
   - Confirming scenarios persist across browser sessions



## TASK 033

# Task ID: 33
# Title: Reorganize Wizard Steps for Improved User Flow
# Status: done
# Dependencies: 32
# Priority: medium
# Description: Reorder the budget wizard steps to follow a more logical progression and restructure the Education and Healthcare steps to separate fixed from variable costs. Integrate Emergency Buffer and FX Sensitivity into the final Summary & Simulation step.
# Details:
This task involves restructuring the wizard flow to improve user experience and logical progression through the budgeting process. Implement the following changes:

1. Reorder the wizard steps to follow this sequence:
   - Step 1: Profile
   - Step 2: Income
   - Step 3: Housing
   - Step 4: Utilities
   - Step 5: Transportation
   - Step 6: Education
   - Step 7: Healthcare
   - Step 8: Lifestyle
   - Step 9: Summary & Simulation

2. Restructure the Education step to clearly separate:
   - Fixed costs (tuition, fees, books)
   - Variable costs (supplies, extracurricular activities)

3. Restructure the Healthcare step to clearly separate:
   - Fixed costs (insurance premiums, regular medications)
   - Variable costs (out-of-pocket expenses, copays)

4. Consolidate functionality by integrating:
   - Emergency Buffer planning into the Summary & Simulation step
   - FX Sensitivity analysis into the Summary & Simulation step

5. Update the WizardContext to reflect the new step order and structure

6. Ensure all navigation controls (next/previous buttons) work correctly with the new flow

7. Update any progress indicators or navigation menus to reflect the new step sequence

8. Maintain all user data during transitions between steps using the existing state persistence system

This reorganization should create a more intuitive flow from personal information to income to expenses, ending with analysis and planning.

# Test Strategy:
1. Verify the wizard steps appear in the correct order by navigating through the entire wizard flow

2. Test that all user data is correctly maintained when navigating between steps in the new order:
   - Enter test data in each step
   - Navigate forward and backward through the wizard
   - Confirm data persists correctly

3. Specifically test the restructured Education and Healthcare steps:
   - Verify fixed and variable costs are clearly separated in the UI
   - Confirm data entry works for both categories
   - Ensure calculations correctly incorporate both fixed and variable costs

4. Test the consolidated Summary & Simulation step:
   - Verify Emergency Buffer functionality is accessible and works correctly
   - Confirm FX Sensitivity analysis can be performed
   - Test that all data from previous steps is correctly summarized

5. Test edge cases:
   - Refresh the browser mid-wizard and verify the correct step loads with data intact
   - Skip optional fields and ensure the flow still works correctly
   - Test with various screen sizes to ensure responsive design works with the new structure

6. Perform user acceptance testing with 2-3 test users to verify the new flow is intuitive and logical

# Subtasks:
## 1. Restructure Education Step (Fixed/Variable Costs) [done]
### Dependencies: None
### Description: Update the Education component UI and state handling to clearly separate fixed costs (tuition, fees) from variable costs (supplies, activities).
### Details:


## 2. Restructure Healthcare Step (Fixed/Variable Costs) [done]
### Dependencies: None
### Description: Update the Healthcare component UI and state handling to clearly separate fixed costs (premiums) from variable costs (OOP, copays).
### Details:




## TASK 034

# Task ID: 34
# Title: Refactor Summary Page into Smaller Components with TypeScript Fixes
# Status: pending
# Dependencies: 36
# Priority: medium
# Description: Break down the summary page component into smaller, reusable sub-components and fix TypeScript errors related to currency calculations to improve code maintainability and type safety.
# Details:
The current implementation in src/app/summary/[scenarioName]/page.tsx is too monolithic and needs to be refactored into smaller, more manageable components:

1. Create the following sub-components in a new directory (src/app/summary/components/):
   - KeyFinancialsDisplay: To show the main financial metrics
   - RequiredGrossIncomeCard: For displaying required income calculations
   - EmergencyBufferCard: For emergency fund information
   - CostBreakdownChart: For visualizing cost distribution
   - SensitivityAnalysisPanel: For currency fluctuation impacts

2. Fix the TypeScript error with originCurrency in the calculateEquivalentValue and formatCurrency function calls:
   - Review the current implementation where these calls are commented out
   - Properly type the currency parameters to ensure type safety
   - Implement proper null/undefined checking for currency values
   - Update the function signatures if necessary to accommodate the correct types

3. Ensure data is correctly passed to all sub-components:
   - Use proper prop typing with interfaces for each component
   - Maintain the existing calculation logic during refactoring
   - Verify that all summary calculations produce the same results after refactoring

4. Update imports and exports accordingly to maintain the component hierarchy

5. Apply consistent styling across all new components, maintaining the current UI appearance

# Test Strategy:
1. Visual Comparison Testing:
   - Take screenshots of the summary page before refactoring
   - Compare with screenshots after refactoring to ensure visual consistency
   - Verify all data points are displayed identically

2. TypeScript Validation:
   - Run 'npm run type-check' or equivalent to verify no TypeScript errors remain
   - Specifically check that the originCurrency-related errors are resolved
   - Ensure no new type errors were introduced during refactoring

3. Functional Testing:
   - Create test scenarios with different currency settings
   - Verify calculations match pre-refactoring results for each scenario
   - Test with both single and multiple currencies to ensure FX calculations work

4. Component Testing:
   - Write unit tests for each new component to verify they render correctly with various props
   - Test edge cases like missing data or zero values
   - Verify that components handle loading states appropriately

5. Code Review Checklist:
   - Confirm component responsibilities are clearly defined with no overlap
   - Verify prop interfaces are comprehensive and well-typed
   - Check that no calculation logic was altered during the refactoring


## TASK 035

# Task ID: 35
# Title: Implement Dedicated Landing Page with Scenario Management
# Status: done
# Dependencies: 32
# Priority: high
# Description: Replace the direct wizard entry with a dedicated landing page that explains the tool's purpose and provides scenario management functionality through interactive cards.
# Details:
Create a new LandingPage component that will serve as the entry point to the application instead of directly showing the wizard. The landing page should include:

1. A clear headline explaining the tool's purpose (budgeting for international relocation)
2. An aspirational background image that sets the tone for the application
3. A prominent 'Start New Scenario' button displayed on its own row
4. A section titled 'Existing Scenarios' that displays saved scenarios as interactive cards

Each scenario card should:
- Display the scenario name and creation/modification date
- Include three action buttons: Load, Delete, and Rename
- Have appropriate hover states and visual feedback

Implementation details:
- When 'Start New Scenario' is clicked, create a new scenario with a temporary name based on timestamp (e.g., 'Scenario - Jan 15, 2023 14:30')
- When 'Load' is clicked on an existing scenario card, load that scenario's data into the wizard
- Both actions should navigate to the wizard interface (AppContent component)
- The 'Delete' action should prompt for confirmation before removing the scenario
- The 'Rename' action should display an inline edit field or modal to capture the new name
- Use the existing WizardContext for managing scenario data
- Ensure the layout is responsive and works well on mobile devices
- Add appropriate animations for transitions between the landing page and wizard

Update the routing configuration to make the landing page the default route, with the wizard accessible at a separate route.

# Test Strategy:
1. Visual verification:
   - Confirm the landing page displays correctly with proper styling, background image, and layout
   - Verify responsive behavior on different screen sizes

2. Functionality testing:
   - Test 'Start New Scenario' button creates a new scenario with timestamp-based name
   - Verify navigation to wizard works correctly after starting a new scenario
   - Confirm existing scenarios are properly loaded from localStorage and displayed as cards

3. Scenario card testing:
   - Test the 'Load' button correctly loads the selected scenario and navigates to wizard
   - Verify 'Delete' button shows confirmation dialog and removes the scenario when confirmed
   - Test 'Rename' functionality correctly updates the scenario name
   - Confirm changes persist after page refresh

4. Edge cases:
   - Test behavior when no existing scenarios are available
   - Verify proper handling of long scenario names in the cards
   - Test with a large number of saved scenarios to ensure performance
   - Verify proper error handling if localStorage is unavailable

5. Integration testing:
   - Confirm the landing page integrates correctly with the WizardContext from Task #32
   - Verify the entire flow from landing page through wizard completion works as expected

# Subtasks:
## 1. Create LandingPage Component with UI Elements [done]
### Dependencies: None
### Description: Develop the LandingPage component with all visual elements including header, background image, and button layout structure
### Details:
Implementation details:
1. Create a new LandingPage.jsx component in the components directory
2. Implement the UI layout with:
   - Header section with title explaining the tool's purpose
   - Background image with appropriate styling
   - 'Start New Scenario' button with proper styling and hover states
   - 'Existing Scenarios' section with a grid or flex layout for cards
   - Responsive design using CSS Grid/Flexbox for different screen sizes
3. Create a basic ScenarioCard component structure with placeholders for:
   - Scenario name display
   - Creation/modification date
   - Action buttons (Load, Delete, Rename) with hover states
4. Add basic CSS animations for hover effects and transitions
5. Implement empty handler functions for button clicks

Testing approach:
- Verify UI renders correctly across different screen sizes
- Check that all visual elements appear as designed
- Confirm hover states work correctly
- Ensure the layout is responsive and adapts to different viewports

## 2. Implement Scenario Management Functionality [done]
### Dependencies: 35.1
### Description: Add the logic for creating, loading, deleting, and renaming scenarios using the WizardContext
### Details:
Implementation details:
1. Update the WizardContext to include functions for:
   - Creating a new scenario with timestamp-based name
   - Loading an existing scenario
   - Deleting a scenario with confirmation
   - Renaming a scenario
2. Connect the 'Start New Scenario' button to create a new scenario:
   - Generate a temporary name based on current timestamp
   - Initialize with default values
   - Store in local storage or state management system
3. Implement the ScenarioCard component functionality:
   - Load button: Load scenario data into WizardContext
   - Delete button: Show confirmation dialog and remove if confirmed
   - Rename button: Display inline edit field or modal for new name input
4. Add proper error handling for all operations
5. Implement the confirmation dialog for delete operations
6. Create the rename modal or inline edit functionality

Testing approach:
- Test creating new scenarios with proper timestamp naming
- Verify scenarios can be loaded correctly
- Test delete functionality with confirmation
- Ensure rename functionality properly updates scenario names
- Check that all error cases are handled gracefully

## 3. Update Routing and Connect Landing Page to Wizard [done]
### Dependencies: 35.1, 35.2
### Description: Configure routing to make the landing page the default route and implement navigation between landing page and wizard
### Details:
Implementation details:
1. Update the routing configuration:
   - Make LandingPage the default route ('/')
   - Move the wizard to a separate route (e.g., '/wizard')
   - Ensure proper navigation between routes
2. Implement navigation logic:
   - After 'Start New Scenario' or 'Load' actions, navigate to the wizard route
   - Add a 'Back to Scenarios' button in the wizard to return to landing page
3. Ensure scenario data persistence between routes:
   - When navigating to wizard, pass the scenario ID or load from context
   - When returning to landing page, ensure any changes are saved
4. Add transition animations between routes for a smooth user experience
5. Implement loading states during navigation or data operations
6. Add proper URL parameters for loading specific scenarios directly
7. Test the complete user flow from landing page to wizard and back

Testing approach:
- Verify routing works correctly for all paths
- Test navigation between landing page and wizard
- Ensure scenario data is maintained correctly during navigation
- Check that URL parameters work for direct scenario loading
- Test browser history navigation (back/forward buttons)
- Verify animations work smoothly during transitions



## TASK 036

# Task ID: 36
# Title: Refactor State Management from Context API to Zustand
# Status: done
# Dependencies: 35
# Priority: medium
# Description: Migrate the application's state management from React Context API to Zustand, implementing a modular store structure with persistence middleware for all state slices.
# Details:
This task involves completely replacing the current Context API implementation with Zustand stores:

1. Create a modular Zustand store structure with separate slices for:
   - User profile data
   - Income information
   - Budget categories and allocations
   - Transportation settings
   - Lifestyle preferences
   - Emergency buffer calculations
   - Wizard step navigation state
   - Currency settings and conversion rates

2. Implement persistence middleware to maintain state across page refreshes using localStorage or similar mechanism.

3. Update all components to consume state from Zustand hooks instead of Context:
   - Replace all useContext calls with appropriate Zustand selectors
   - Update AppContent component to use the new state management
   - Modify all wizard step components to read/write state via Zustand
   - Refactor the summary page to pull data from Zustand stores

4. Ensure proper TypeScript typing throughout the implementation:
   - Define interfaces for each state slice
   - Type all store actions and selectors
   - Maintain type safety in component connections

5. Implement selective state updates to prevent unnecessary re-renders

6. Add appropriate error handling and fallback mechanisms for state operations

The goal is to improve application architecture by making state management more modular, simplifying cross-component state sharing, and preparing for future AppContent component breakdown.

# Test Strategy:
Testing should verify both the technical implementation and functional equivalence:

1. Unit Tests:
   - Create tests for each Zustand store slice to verify state updates work correctly
   - Test persistence middleware functionality by simulating page reloads
   - Verify type safety with TypeScript compiler checks

2. Integration Tests:
   - Ensure all components correctly receive and update state
   - Verify that state changes in one component properly propagate to others
   - Test cross-slice state dependencies (e.g., currency changes affecting budget calculations)

3. Functional Verification:
   - Create a test matrix comparing all app behaviors before and after refactoring
   - Manually verify each wizard step functions identically to the previous implementation
   - Test the complete user flow from start to finish to ensure no regressions
   - Verify that all calculations and data transformations produce identical results

4. Performance Testing:
   - Measure and compare render performance before and after the refactoring
   - Check for unnecessary re-renders using React DevTools
   - Verify memory usage patterns remain stable or improve

5. Edge Cases:
   - Test behavior when localStorage is unavailable or corrupted
   - Verify state consistency during rapid user interactions
   - Test with various data volumes to ensure scalability

# Subtasks:
## 1. Create transport.types.ts with TransportState type [done]
### Dependencies: None
### Description: Create the TransportState type definition in @/types/transport.types.ts based on the existing Transport interface from the TransportContext. This will resolve the linter error in wizardSlice.ts.
### Details:


## 2. Create lifestyle.types.ts with LifestyleState type [done]
### Dependencies: None
### Description: Create the LifestyleState type definition in @/types/lifestyle.types.ts based on the existing LifestyleState interface from the LifestyleContext. This will resolve the linter error in wizardSlice.ts.
### Details:


## 3. Create budget.ts with BudgetState type [done]
### Dependencies: None
### Description: Create the BudgetState type definition in @/types/budget.ts that combines all state slices. This will resolve the circular dependency issue in wizardSlice.ts.
### Details:


## 4. Create CurrencyContext and related types [done]
### Dependencies: None
### Description: Create the CurrencyContext and its related types to resolve the import error in the wizard page. This includes defining currency-related types and implementing proper integration with the wizard slice.
### Details:




## TASK 037

# Task ID: 37
# Title: Refactor AppBudgetContext into Domain-Specific Context Modules
# Status: pending
# Dependencies: None
# Priority: high
# Description: Decompose the monolithic AppBudgetContext into separate domain-specific contexts for Housing, Utilities, Education, Healthcare, and Household, while maintaining backward compatibility and updating all dependent components.
# Details:
This refactoring task involves breaking down the current monolithic AppBudgetContext into smaller, more focused context modules following the domain-driven design approach. The implementation should:

1. Create separate context modules for each domain area:
   - HousingContext
   - UtilitiesContext
   - EducationContext
   - HealthcareContext
   - HouseholdContext

2. Follow the established patterns from existing Income/Transport/Lifestyle contexts for consistency, including:
   - State structure and initialization
   - Provider implementation
   - Hook creation (useHousingContext, etc.)
   - Type definitions

3. Implement a composition strategy for the providers to maintain the hierarchy and data flow between contexts. Consider using a ContextComposer component or nested providers pattern.

4. Update all components that currently consume AppBudgetContext to use the appropriate domain-specific contexts instead.

5. Handle cross-context calculations by implementing a strategy for contexts to access data from other contexts when needed (possibly through a shared calculation service or context references).

6. Ensure state persistence works correctly for all new context modules, maintaining compatibility with the existing storage mechanism.

7. Update the wizard flow to properly initialize and utilize the new context structure without changing the user experience.

8. Maintain backward compatibility by either:
   - Creating a facade over the new contexts that mimics the old AppBudgetContext interface
   - Gradually migrating components to use the new contexts while maintaining both systems temporarily

9. Document the new context structure and provide usage examples for other developers.

# Test Strategy:
Testing should verify both the technical implementation and functional preservation:

1. Unit Tests:
   - Create unit tests for each new context module to verify state initialization, updates, and calculations
   - Test the provider components in isolation
   - Verify custom hooks return expected values
   - Test type safety with TypeScript compiler checks

2. Integration Tests:
   - Test the composition of multiple contexts to ensure they work together correctly
   - Verify cross-context calculations produce the same results as before
   - Test state persistence and retrieval for all new contexts

3. Functional Tests:
   - Create snapshot tests of key components before and after the refactoring
   - Implement end-to-end tests that walk through the entire wizard flow
   - Verify all calculations produce identical results to the previous implementation
   - Test edge cases where multiple contexts interact

4. Regression Testing:
   - Create a comprehensive test suite that compares outputs from the old and new implementations
   - Test with various input scenarios to ensure calculations remain consistent
   - Verify that all UI components render correctly with the new context structure

5. Performance Testing:
   - Measure and compare render performance before and after the refactoring
   - Check for any memory leaks or excessive re-renders
   - Verify that state updates remain efficient

# Subtasks:
## 1. Create Base Structure for Domain-Specific Contexts [pending]
### Dependencies: None
### Description: Define the base structure for all domain-specific contexts including types, interfaces, and state shapes
### Details:
Implementation steps:
1. Define a common interface for all domain contexts (similar to existing Income/Transport/Lifestyle contexts)
2. Create TypeScript interfaces for each domain's state (HousingState, UtilitiesState, etc.)
3. Define initial state objects for each domain context
4. Create empty context files for each domain (HousingContext.tsx, UtilitiesContext.tsx, etc.)
5. Extract relevant state properties from AppBudgetContext to each domain context
6. Ensure proper typing for all extracted properties
7. Document the new structure with comments

Testing approach:
- Validate TypeScript types compile without errors
- Review state structure to ensure all properties from AppBudgetContext are properly distributed

## 2. Implement Provider Components for Each Domain Context [pending]
### Dependencies: 37.1
### Description: Create provider components for each domain context with proper state management
### Details:
Implementation steps:
1. Implement provider components for each domain context (HousingProvider, UtilitiesProvider, etc.)
2. Add useState/useReducer hooks to manage state in each provider
3. Create context value objects with state and updater functions
4. Implement the Provider component JSX with proper value prop
5. Add necessary action creators and reducer functions for state updates
6. Ensure each provider follows the same pattern as existing contexts
7. Create custom hooks for each context (useHousingContext, useUtilitiesContext, etc.)

Testing approach:
- Create simple test components that use each provider
- Verify state updates work correctly within each isolated context
- Test custom hooks to ensure they return the expected context values

## 3. Implement Context Composition Strategy [pending]
### Dependencies: 37.2
### Description: Create a composition mechanism to maintain hierarchy between contexts
### Details:
Implementation steps:
1. Design a ContextComposer component that nests providers in the correct order
2. Determine the correct nesting order based on data dependencies
3. Implement the ContextComposer with all domain providers
4. Create a mechanism for cross-context communication if needed
5. Ensure context providers can access data from other contexts when required
6. Add proper typing for the composed context structure
7. Update the main application to use the ContextComposer

Testing approach:
- Test the ContextComposer with mock providers
- Verify data flows correctly between nested contexts
- Ensure the component tree renders without errors

## 4. Create Backward Compatibility Layer [pending]
### Dependencies: 37.2, 37.3
### Description: Implement a facade over the new contexts to maintain backward compatibility
### Details:
Implementation steps:
1. Create a compatibility provider that mimics the old AppBudgetContext interface
2. Implement a useAppBudgetContext hook that aggregates data from all domain contexts
3. Map old state properties and methods to the new context structure
4. Ensure all existing functionality remains accessible through the compatibility layer
5. Add deprecation warnings when using the compatibility layer
6. Document migration path for components still using AppBudgetContext
7. Test with existing components to ensure they continue to work

Testing approach:
- Compare outputs of old context vs. compatibility layer
- Test with components that use the old context
- Verify all methods and properties are accessible through the compatibility layer

## 5. Update State Persistence Mechanism [pending]
### Dependencies: 37.2, 37.3
### Description: Ensure state persistence works correctly for all new context modules
### Details:
Implementation steps:
1. Analyze the current state persistence implementation
2. Modify persistence logic to work with the new context structure
3. Implement save/load functions for each domain context
4. Ensure data is correctly serialized and deserialized
5. Handle migration of existing saved data to the new format
6. Test persistence across page reloads
7. Add error handling for data migration edge cases

Testing approach:
- Save state, reload the application, and verify state is restored
- Test with existing saved data to ensure migration works
- Verify all domain contexts correctly persist their state

## 6. Migrate First Set of Components to New Contexts [pending]
### Dependencies: 37.4
### Description: Update half of the components that use AppBudgetContext to use the new domain contexts
### Details:
Implementation steps:
1. Identify all components that currently use AppBudgetContext
2. Prioritize components based on complexity and dependencies
3. Update the first 50% of components to use appropriate domain contexts
4. Replace useAppBudgetContext with domain-specific hooks
5. Update prop types and component interfaces as needed
6. Test each migrated component thoroughly
7. Document any patterns or issues discovered during migration

Testing approach:
- Compare component behavior before and after migration
- Test user interactions to ensure they work as expected
- Verify data flow between components and contexts

## 7. Migrate Remaining Components to New Contexts [pending]
### Dependencies: 37.6
### Description: Update the remaining components to use the new domain contexts
### Details:
Implementation steps:
1. Migrate the remaining components to use domain-specific contexts
2. Apply patterns and lessons learned from the first migration batch
3. Update any shared utilities or helpers that use AppBudgetContext
4. Refactor any complex components that interact with multiple domains
5. Ensure wizard flows correctly initialize and use the new contexts
6. Update any tests that mock AppBudgetContext
7. Remove usage of the compatibility layer where possible

Testing approach:
- Run full application tests to ensure all features work
- Test wizard flows end-to-end
- Verify all components render and function correctly

## 8. Finalize Documentation and Clean Up [pending]
### Dependencies: 37.5, 37.7
### Description: Complete documentation, remove deprecated code, and finalize the refactoring
### Details:
Implementation steps:
1. Create comprehensive documentation for the new context structure
2. Provide usage examples for each domain context
3. Document cross-context interactions and best practices
4. Remove the compatibility layer if all components have been migrated
5. Clean up any temporary code or comments
6. Update README and developer documentation
7. Create a migration guide for future development

Testing approach:
- Perform a final full application test
- Verify no references to the old AppBudgetContext remain
- Review documentation for completeness and accuracy
- Have another developer test using the new contexts based on documentation



## TASK 038

# Task ID: 38
# Title: Codebase Cleanup: Remove Legacy Context Files and Unused Code
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Remove all legacy context files, unused utility functions, and deprecated code that were made obsolete by the migration to Zustand for state management.
# Details:
This task involves systematically identifying and removing code that is no longer needed after the Zustand migration. Specifically:

1. Remove the CurrencyContext and any other context files that have been replaced by Zustand stores
2. Delete any utility functions that were specifically created for the Context API implementation
3. Clean up imports across the codebase that reference these removed files
4. Remove any deprecated code patterns or components that were only needed for the previous state management approach
5. Update documentation to reflect the current state management architecture
6. Ensure no references to removed contexts remain in component files
7. Check for and remove any unused hooks that were created for the Context API
8. Verify that no dead code paths exist that reference the old implementation
9. Run the application to ensure no runtime errors occur after cleanup
10. Optimize bundle size by removing unnecessary exports

Before deleting any file, verify it's not being used by searching for imports across the codebase. Use tools like 'npm prune' to identify unused dependencies that might be related to the old implementation.

# Test Strategy:
To verify this task has been correctly implemented:

1. Static Analysis:
   - Run ESLint with the 'no-unused-vars' rule enabled to catch any remaining unused imports
   - Use a tool like 'depcheck' to identify any unused dependencies
   - Search the codebase for strings like 'Context', 'useContext', and specific context names to ensure they've been removed

2. Build Verification:
   - Ensure the application builds without warnings or errors
   - Compare bundle size before and after changes to confirm reduction

3. Runtime Testing:
   - Perform a full regression test of all application features to ensure nothing was broken
   - Test all state-dependent features to verify they still work with Zustand
   - Check browser console for any errors during application usage

4. Code Review:
   - Have another developer review the PR to ensure no critical code was accidentally removed
   - Document all removed files and components in the PR description

5. Performance Testing:
   - Measure application load time before and after to verify improvement
   - Profile memory usage to ensure no memory leaks were introduced

# Subtasks:
## 1. Analyze and Map Legacy Context Files to Zustand Stores [pending]
### Dependencies: None
### Description: Create a comprehensive mapping between legacy context files and their Zustand store replacements to guide the cleanup process.
### Details:
Implementation steps:
1. Create a spreadsheet or document that lists all context files in the codebase
2. For each context file, identify the corresponding Zustand store that replaced it
3. Document the key exports, hooks, and utilities from each context file
4. Use grep or codebase search to find all imports of each context file
5. Count references to each context file to prioritize cleanup
6. Mark files that are definitely unused vs. those that might still have dependencies

Testing approach:
- This is a preparatory task, so testing involves verifying the completeness of the mapping
- Cross-check with team members who worked on the Zustand migration
- Ensure all context files are accounted for in the mapping document

## 2. Remove CurrencyContext and Primary Context Files [pending]
### Dependencies: 38.1
### Description: Remove the main context files that have been fully replaced by Zustand stores, starting with CurrencyContext.
### Details:
Implementation steps:
1. Based on the mapping from subtask 1, identify the CurrencyContext and other primary context files
2. Create a git branch specifically for this cleanup task
3. Remove the CurrencyContext.js/ts file
4. Remove other primary context files identified as fully replaced
5. Run the build process to identify any immediate build errors
6. Fix any build errors by removing imports in files that referenced the deleted contexts
7. Commit these changes with clear commit messages

Testing approach:
- Run the build process after each context removal
- Run unit tests to ensure no test failures
- Manually test key application flows that previously used these contexts
- Verify that Zustand stores are properly handling the state management

## 3. Remove Utility Functions and Hooks Specific to Context API [pending]
### Dependencies: 38.1, 38.2
### Description: Identify and remove utility functions and custom hooks that were created specifically for the Context API implementation.
### Details:
Implementation steps:
1. From the mapping document, identify utility functions and hooks that were specifically created for Context API
2. Search the codebase for any remaining references to these utilities
3. Remove utility files that have no remaining references
4. For utilities with references, replace them with Zustand equivalents or remove the references
5. Focus on hooks like useContext wrappers or context-specific selector functions
6. Check for any higher-order components that were used for context consumption
7. Remove any context provider wrapper components

Testing approach:
- Run the application after each significant removal
- Test specific features that used these utilities
- Verify that all functionality works with the Zustand implementation
- Run the test suite to catch any regressions

## 4. Clean Up Component Imports and References [pending]
### Dependencies: 38.2, 38.3
### Description: Systematically clean up imports and references to removed context files and utilities across all component files.
### Details:
Implementation steps:
1. Use tools like grep, VSCode search, or specialized code search tools to find all imports referencing removed files
2. Create a list of files that need import cleanup
3. For each file, remove unused imports related to the old context system
4. Check for and remove any unused variables or functions that were related to context consumption
5. Look for patterns like useContext calls or Context.Consumer components
6. Remove any withContext HOC usage
7. Ensure components are properly using Zustand hooks instead

Testing approach:
- Run the build after cleaning up each major component
- Test components individually to ensure they still function correctly
- Check for console errors related to missing imports
- Verify that state management still works correctly in the UI

## 5. Remove Deprecated Code Patterns and Dead Code Paths [pending]
### Dependencies: 38.2, 38.3, 38.4
### Description: Identify and remove deprecated code patterns, dead code paths, and any conditional logic that was only relevant to the Context API implementation.
### Details:
Implementation steps:
1. Look for conditional code that might be checking for context existence
2. Remove any fallback patterns that were designed for context API limitations
3. Check for commented-out code related to the old implementation
4. Remove any feature flags that were used during the migration period
5. Look for any defensive coding patterns that are no longer needed
6. Remove any performance optimizations that were specific to preventing context re-renders
7. Clean up any PropTypes or TypeScript interfaces that are no longer used

Testing approach:
- Run the application and navigate through key user flows
- Check for any runtime errors or unexpected behavior
- Verify that the application behaves consistently across different scenarios
- Run performance tests to ensure no regressions

## 6. Update Documentation and Optimize Bundle Size [pending]
### Dependencies: 38.1, 38.2, 38.3, 38.4, 38.5
### Description: Update documentation to reflect the current state management architecture and perform final optimizations to reduce bundle size.
### Details:
Implementation steps:
1. Update README files and developer documentation to remove references to Context API
2. Update architecture diagrams or documentation to show Zustand-based state management
3. Create or update state management guidelines for the team
4. Run 'npm prune' to remove any unused dependencies related to the old implementation
5. Check bundle size before and after cleanup to quantify improvements
6. Use tools like webpack-bundle-analyzer to identify any remaining opportunities for optimization
7. Remove any unnecessary exports from barrel files
8. Ensure that Zustand stores are properly configured for code splitting if applicable

Testing approach:
- Verify documentation accuracy with team review
- Run the full test suite to ensure no regressions
- Perform end-to-end testing of critical user journeys
- Compare bundle sizes before and after to confirm optimization
- Deploy to a staging environment for final verification



## TASK 039

# Task ID: 39
# Title: Implement Comprehensive Testing Infrastructure with Jest and React Testing Library
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Set up and implement a complete testing infrastructure for the project using Jest and React Testing Library, including unit, component, and integration tests with CI pipeline integration.
# Details:
This task involves establishing a robust testing framework for the entire application:

1. **Setup and Configuration**:
   - Install and configure Jest, React Testing Library, and related dependencies
   - Set up Jest configuration in jest.config.js with appropriate transforms, module mappers, and coverage settings
   - Configure testing environment variables and mocks for external dependencies
   - Create test utilities for common testing patterns (e.g., render helpers, mock store creators)

2. **Test Structure Implementation**:
   - Establish a consistent directory structure for tests (e.g., `__tests__` folders or `.test.js` files alongside components)
   - Create test templates for different component types (presentational, container, hooks, etc.)
   - Implement test patterns for Zustand stores and selectors
   - Set up mock implementations for external services and APIs

3. **Test Coverage Types**:
   - Unit tests: For utility functions, hooks, and store logic
   - Component tests: For individual React components with mocked dependencies
   - Integration tests: For connected components that interact with stores
   - Snapshot tests: For UI component stability verification

4. **CI Integration**:
   - Configure test runs in the CI pipeline
   - Set up test reporting and artifacts
   - Implement coverage thresholds and reporting
   - Configure test caching for improved CI performance

5. **Documentation**:
   - Create documentation for the testing approach
   - Provide examples of each test type
   - Document mocking strategies and test utilities

# Test Strategy:
The implementation will be verified through the following methods:

1. **Infrastructure Verification**:
   - Confirm Jest and React Testing Library are properly installed and configured
   - Verify test scripts in package.json work correctly
   - Ensure test coverage reporting is functioning
   - Validate that the CI pipeline successfully runs tests

2. **Test Implementation Verification**:
   - Review sample tests for each component type to ensure they follow best practices
   - Verify at least one example test exists for:
     - A presentational component
     - A container component with store interactions
     - A custom hook
     - A utility function
     - A Zustand store
     - An integration test covering multiple components

3. **Coverage and Quality Checks**:
   - Run test coverage report and verify it meets minimum threshold (suggest 70%)
   - Ensure tests are meaningful (not just shallow rendering)
   - Verify tests use proper assertions and don't have false positives

4. **CI Integration Testing**:
   - Push a failing test and confirm CI catches it
   - Push a passing test and confirm CI reports success
   - Verify test reports are properly generated and accessible

5. **Documentation Review**:
   - Confirm documentation clearly explains the testing approach
   - Verify examples are provided for all test types
   - Ensure new developers can understand how to write tests

# Subtasks:
## 1. Install and Configure Jest and React Testing Library [pending]
### Dependencies: None
### Description: Set up the foundational testing tools and configuration for the project
### Details:
Implementation steps:
1. Install Jest, React Testing Library, and related dependencies (jest-dom, user-event, etc.) using npm/yarn
2. Create jest.config.js with appropriate settings:
   - Configure module mappers for non-JS imports
   - Set up transform configurations for TypeScript/JSX
   - Configure test environment (jsdom)
   - Set up coverage reporting paths and thresholds
3. Create setupTests.js file to import jest-dom extensions
4. Configure package.json with test scripts:
   - Standard test run
   - Watch mode for development
   - Coverage report generation
   - CI-specific test command
5. Create a .env.test file for test-specific environment variables

Testing approach:
- Verify configuration by running a simple test
- Ensure all transforms work by testing imports of different file types
- Confirm coverage reporting works correctly

## 2. Create Test Utilities and Mocking Infrastructure [pending]
### Dependencies: 39.1
### Description: Develop reusable test utilities and mock implementations for external dependencies
### Details:
Implementation steps:
1. Create a test-utils.js file with:
   - Custom render function that includes providers (Router, Theme, Store)
   - Helper for creating pre-populated test stores
   - User interaction utilities
2. Set up mock implementations for:
   - API services using jest.mock()
   - External libraries and services
   - Browser APIs (localStorage, fetch, etc.)
3. Create fixtures directory with sample test data
4. Implement common test assertions as custom matchers
5. Set up MSW (Mock Service Worker) for API mocking if needed

Testing approach:
- Create tests for the utilities themselves
- Verify mocks work by writing a test that uses them
- Test the custom render function with a simple component

## 3. Implement Component and Unit Test Templates [pending]
### Dependencies: 39.1, 39.2
### Description: Create standardized test patterns for different component types and application logic
### Details:
Implementation steps:
1. Create test templates for:
   - Presentational components (focusing on rendering and user interaction)
   - Container components (testing integration with stores)
   - Custom hooks (using renderHook)
   - Context providers
   - Utility functions
2. Implement Zustand store testing patterns:
   - Store creation tests
   - Action and selector tests
   - Store integration tests
3. Set up snapshot testing configuration
4. Create example tests for each component type
5. Implement test directory structure (either __tests__ folders or co-located .test.js files)

Testing approach:
- Verify each template works with actual components
- Ensure test isolation between different test types
- Check that snapshots are generated correctly

## 4. Configure CI Pipeline Integration for Tests [pending]
### Dependencies: 39.1, 39.2, 39.3
### Description: Set up continuous integration configuration for running tests automatically
### Details:
Implementation steps:
1. Create CI configuration file (e.g., .github/workflows/test.yml for GitHub Actions)
2. Configure test runs with:
   - Appropriate Node.js version
   - Dependency caching
   - Parallel test execution if applicable
3. Set up test reporting:
   - Configure Jest to output JUnit XML reports
   - Set up coverage reporting in CI-friendly format
4. Implement test failure notifications
5. Configure branch protection rules requiring tests to pass

Testing approach:
- Push a test commit to verify CI pipeline runs correctly
- Intentionally break a test to verify failure reporting
- Check that coverage reports are generated and accessible

## 5. Create Testing Documentation and Examples [pending]
### Dependencies: 39.1, 39.2, 39.3, 39.4
### Description: Document the testing approach and provide comprehensive examples for the team
### Details:
Implementation steps:
1. Create a TESTING.md file in the project root with:
   - Overview of testing philosophy and approach
   - Instructions for running tests locally
   - Guidelines for writing different types of tests
   - Explanation of mocking strategies
2. Add inline documentation to test utilities and helpers
3. Create a tests/examples directory with annotated examples of:
   - Unit tests for utilities
   - Component tests with RTL
   - Integration tests
   - Store/state management tests
4. Document coverage requirements and thresholds
5. Add testing section to the main README.md with quick start information

Testing approach:
- Review documentation with team members for clarity
- Have a new team member try to write a test following the documentation
- Ensure all examples run successfully

